<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>Study Data Structure | Shaofeng's Page</title>
<meta property="og:title" content="Shaofeng's Page" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A personal page of Shaofeng Wu." />

<link rel="stylesheet" href="../../css/style-mainpage.css">
<script src="/modernist/assets/js/scale.fix.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

<link rel="shortcut icon" href="../../img/emilia.png"><!--logo-->
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>

  <body>
    <div id="particles-js"></div><!-- particle effect scripts -->
    <script src="../../js/particles.js"></script>
    <script src="../../js/app.js"></script>

  <div id="allpart">
  <div class="wrapper" id="contentpart">
    <header >
      <h1>伍少枫的个人主页</h1>
      <p>Shaofeng's Personal Website</p>
    <p class="view"><a href="https://github.com/ShaofengWu123/ShaofengWu123.github.io">View the Project on GitHub <small></small></a></p>
    <ul>
    <li><a href="https://github.com/ShaofengWu123/ShaofengWu123.github.io">View On <strong>GitHub</strong></a></li>
    </ul>
    </header>
    <section>
      <h1>Data Structure</h1><!-- main title -->

      <ul>
      <li><a href="#ds-outline">Content outline</a></li><!--content list -->
      <li><a href="#ds-lab">Labs</a></li> 
      </ul>
      <hr>

      <h2><a id="ds-outline">Content outline</a></h2>
      <p>
        <ul>
          <li>Linear list/线性表</li>
          <ul>
            <li>基本定义:<br>n(n>=0)个具有相同特性元素组成的有限序列。</li>
            <li>顺序实现：顺序表
            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define LIST_INIT_SIZE 100
#define LIST_INCREMENT 10
typedef struct _sqlist{
    Elemtype* elem;
    int length;
    int size;
}SqList;</code></pre></div></div></li>
            <li>链式实现：链式表 (用一组任意的存储单元存储线性表中元素)
            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define LIST_INIT_SIZE 100
typedef struct _lnode{
    Elemtype* elem;
    struct _lnode * next;  
}Lnode,*LinkList;</code></pre></div></div></li>
            其他的链式表：循环链表（尾部next回到头结点head）、双向循环链表
            <li>典型问题</li>
            <ul>
              <li>顺序表和链式表的比较，例如是否能随机存取和顺序存取</li>
              <li>时间复杂度分析：线性表插入、删除，链式表插入、删除...</li>
              <li>容易搞错的基本操作：清空表、销毁表</li>
            </ul>
          </ul>

          <li><abbr title="仅限定在表尾或者说栈顶进行插入删除操作的特殊线性表，LIFO">Stack</abbr></li> 
          <ul>
            <li>顺序实现：顺序栈
              <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define STACK_INIT_SIZE 100
#define STACK_INCREMENT 10
  typedef struct _sqstack{
      Elemtype* base;
      Elemtype* top;
      int stacksize;//已分配的存储空间
  }SqStack;</code></pre></div></div>
  栈空：base==top，栈满：top-base==stacksize
</li>
            <li>链式实现：链式栈
              <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct _stacknode{
  Elemtype data;
  struct _stacknode * next;
}StackNode;

typedef struct _linkstack{
  StackNode * top;
}LinkStack;</code></pre></div></div>
            </li>
            <li>基本操作的实现：判断栈空，出栈，入栈，清空栈，销毁栈</li>
            <li>栈的应用
              <ul>
                <li>数制转换计算时储存结果并按顺序输出</li>
                <li>行编辑器的实现</li>
                <li>检测括号匹配</li>
                <li>中缀式求值：
                  <ul>
                    <li>双栈求值（符号栈和数字栈）：<br>&nbsp &nbsp 数字入栈；当前符号优先级小于栈顶符号优先级，处理栈顶符号；当前符号优先级大于栈顶符号优先级，入栈等待；相等，消配对括号</li>
                    <li>中缀式转后缀式（逆波兰式）:<br>&nbsp &nbsp 方法和双栈求值类似，注意碰到右括号时一直出栈直到左括号出栈；逆波兰式求值一次弹出两个数字，此时运算顺序已经排列好了</li>
                  </ul>
                <li>函数调用
                  <ul>
                    <li>调用过程：<abbr title="包括返回地址、局部变量、寄存器。不同语言、不同编译器存在差异">栈帧</abbr>入栈、执行被调函数、出栈、按返回地址继续执行主调函数</li>
                    <li><abbr title="直接或间接调用、定义自己">递归</abbr>
                      <ul>
                        <li>典型问题：汉诺塔、斐波那契数列、阶乘时间空间复杂度（On）</li>
                        <li>提高算法时空性能：尾递归、全局栈存储信息</li>
                      </ul>
                    </li>
                  </ul>
                </li>
                </li>
              </ul>
            </li>
          </ul>

          <li><abbr title="仅限定在一端进行插入，另一端进行删除的特殊线性表，FIFO">Queue</abbr>
            <ul>
              <li>链式实现：链式队列
                <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct _queuenode{
  Elemtype data;
  struct _queuenode * next;
}QueueNode;
                
typedef struct _linkqueue{
  QueueNode * front, *rear;//front指针恒等于head，这样出队方便改变指针指向
}LinkQueue;</code></pre></div></div>
              </li>
              <li>顺序实现：循环队列
                <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define MAXSIZE 100
typedef struct _sqqueue{
  Elemtype *queue;
  int front, rear;//用下标指示队头队尾
}SqQueue;</code></pre></div></div>
                <ul>
                  循环队列留出一个位置用于区分队满和队空
                  <li>入队：rear = (rear+1)%MAXSIZE</li>
                  <li>出队：front = (front+1)%(MAXSIZE-1)</li>
                  <li>判断队满：front==(rear+1)%MAXSIZE</li>
                  <li>判断队空：front==rear</li>
                </ul>
              </li>
            </ul>
          </li> 

          <li><abbr title="0个或多个字符组成的有限序列">String</abbr>
            <ul>
              <li>基本概念<br>&nbsp &nbsp 串值、串长、空串、<abbr title="空格组成的串">空白串</abbr>、子串、<abbr title="从1开始计数，要注意英文字符、数字等为1字节，汉字是2字节">子串的位置</abbr>、串相等、串变量、串常量</li>
              <li>定长顺序存储实现
                <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define MAXSTRLEN 100
typedef struct _sstring{
  unsigned char str[MAXSTRLEN+1];//0位置存储串长
}SString;</code></pre></div></div>
              </li>
              <li>堆分配存储实现
                <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define INITSTRLEN 100
typedef struct _hstring{
  char * ch;
  int length;
}HString;</code></pre></div></div>
              堆分配要注意做操作时要要释放原来的空间，因为原来内存可能被占用
              </li>
              <li>块链存储实现
                <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define BLOCK_SIZE 4
typedef struct _bnode{
  char data[BLOCK_SIZE];//以Bnode为单元，每个单元BLOCK_SIZE个字符，为了提高内存利用率；若不够一个单元，用'@'占位
  struct _bnode * next;
}Bnode;
typedef struct _bstring{
  Bnode * head;
  int strlne;
}BString;</code></pre></div></div>               
              </li>
              <li>串的模式匹配
                <ul>
                  <li>暴力模式匹配 <br> &nbsp &nbsp 时间复杂度O(nm)，即每次都在最后一个出错，实际情况下近似于O(n+m)</li>
                  <li>KMP算法
                    <ul>
                      <li>算法核心思想：对模式串T计算next[]数组，当T的j位置失配，j=next[j]，即按照寻路表向右滑动一定距离</li>
                      <li>求next[]数组
                        <ul>
                          <li>暴力（穷举）法：比较长1,2，...，j-1的子串</li>
                          <li>改进穷举法：先比较长1,2，...，j-1的子串最后一位，相等再比较这两个子串</li>
                          <li>递推法（实现类似KMP算法）
                            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void next3(int next[], SString T) {
  next[0] = T[0];
	next[1] = 0;
	next[2] = 1;
	int i=2, j =1;
  while(i&ltT[0]){
    if(j==0||T[i]==T[j]){i++;j++;next[i]=j}
    else{j=next[j];}
  }
}
</code></pre></div></div>
                          </li>
                        </ul>
                      <li>KMP算法
                        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int KMP_SString(SString S, SString T, int pos, int next[]) {
  if (pos <= 0 || pos > S[0]) { return -1; }//检查pos是否合法
    int j = 1; int i = 1;
    while (j<=T[0]&&i<=S[0]) {
      if (j == 0 || S[i] == T[j]) { i++; j++; }//首个字符失配（此时j=0，是非法的值）或者当前字符匹配，i和j都往后移动一下
      else { j = next[j]; }
    }
    if (j > T[0]) { return i - T[0]; }
    return -1;
  }</code></pre></div></div>
                      </li>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>

          <li><abbr title="n(n>1)个具有相同特性数据元素组成的地址连续的有限序列。数组采用随机存取，可以视为线性表的推广，其中数据元素可以是一个数据结构。">Array</abbr>
            <ul>
              <li>存储方式
                <ul>
                  <li>二维数组：<abbr title="同一行的元素优先放在连续的地址空间">行优先存放</abbr>、列优先存放
                  <br>行优先存放：LOC(i,j) = a + (in+j)L
                  </li>
                  <li>n维数组：映象函数。n维数组由b1个n-1维数组构成，以此类推。<br> LOC(j1,j2,j3,...,jn) = a + Σciji ,其中ci是第i维地址系数，用于提高运算速度，ji是第i维坐标<br>cn = L, cj-1 = cj * bj</li>
                </ul>
              </li>
              <li>顺序实现
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct _array{
  Elemtype * base;//数组元素基址
  int dim;//维度
  int * bounds;//各维度元素个数存放基址
  int * constant;//各维度地址系数存放基址  
}
</code></pre></div></div>                
              </li>
              <li>C语言实现参数个数可变函数：
                <ul>
                  <li>va_list类型：存放变参</li>
                  <li>va_start(va_list, n)：从本函数参数中读取变参到va_list变参表中</li>
                  <li>va_arg(va_list, int)：以int类型读取从va_list中读取一个参数，每读取一个下次读取会自动读下一个</li>
                  <li>va_end(va_list)：结束读取，与va_start配合使用</li>
                </ul>
              </li>
            </ul>
          </li>

          <li><abbr title="0和非零元素分布有一定规律的矩阵">特殊矩阵</abbr>
          <ul>
            <li>对称矩阵、二对角矩阵、三对角矩阵：顺序压缩存储映象函数的求解 <br> 一般为线性关系，通过 k = ai + bj + c 解方程来求解</li>
            <li><abbr title="非零元素远少于0元素的矩阵"></abbr>稀疏矩阵(Sparse Matrix)
              <ul>
                <li>顺序存储实现：三元组表(Triple)
                <img src="三元组表.png"><br>
                代码实现:带先后顺序结构体数组<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define MAXSIZE 12500
typedef struct _triple{
  Elemtype e;
  int i,j;
}Triple;

typedef struct _tsmatrix{
  Triple data[MAXSIZE+1];//索引0处未用，行为主序（行数小的在前面）
  int mu, nu, tu;//行数、列数、非零元素数
}TSMatrix;</code></pre></div></div> 
                </li>
                <li>链式存储实现：十字链表
                  <img src="十字链表.png"><br>
                  代码实现:两个指针数组加一堆链表节点相连<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct _olnode{
  Elemtype e;
  struct _olnode * down, *right;
  int i,j;//该节点的行、列数，设置此域是为了方便建立十字链表的时候找到插入节点的位置
}OLnode;

typdef struct _crosslist{
  int mu,nu,tu;//行数、列数、非零元素数
  OLnode ** chead, rhead;//列指针、行指针数组
}CrossList;
</code></pre></div></div> 
十字链表的优点：<br>对于需要大量移动非零元素位置的操作，十字链表比三元组表更加容易。例如转置（递归交换down和right指针即可）、等于x的元素置零（递归实现，递归过程中记录递归来源节点的指针从而修改链表连接关系，例如将上一个节点的right指针指向被置零节点的right）等操作
                </li>
                <li>注意事项：<br> &nbsp &nbsp 绘制三元组表要注意行/列为主序，列/行为次序；绘制十字链表注意节点包括行、列、值和down、right</li>
              </ul>
            </li>
            <li>三元组表实现矩阵转置操作
              <li>方法1：先交换行号和列号，再按照行先序、列次序的顺序进行排序</li>
              <li>方法2：从列号j=1开始，重复从前往后搜索列号等于j的元素（先搜索到的元素行号更小），然后放入新的三元组表内，对j=1到j=n循环。时间复杂度O(tu*nu)，即每次都要搜索表，要搜索nu次</li>
            </li>
          </ul>
          </li>

          <li><abbr title="n(n>=0)个元素组成的有限序列，其中元素可以是原子，也可以是广义表。广义表是线性表的推广">广义表（Lists）</abbr>
            <ul>
              <li>基本定义
                <ul>
                  <li>表头：表非空时，表中第一个元素称作表头。</li>
                  <li>表尾：除去表头其他元素组成的<strong>广义表</strong>称作表尾。</li>
                  <li>表长：广义表中元素的个数。</li>
                  <li>表深：广义表中括号的最大层数。空表的深度为0。</li>
                </ul>
              </li>
              <li>常见问题
                <ul>
                  <li>广义表与线性表的区别？ <br>答：广义表元素可以是原子也可以是广义表，而线性表的元素是原子。广义表是线性表的推广。</li>
                  <li>广义表的表尾是？ <br>答：广义表。</li>
                  <li>空广义表的长度是？深度是？ <br>答：长度为0，深度也为0。</li>
                  <li>一个递归定义的广义表，例如 E = (a,E) 表长是多少？表深又是多少？ <br>答：表长为2，表深为无穷。</li>
                  <li>如何唯一确定一个广义表？ <br>答：一个确定的表头和一个确定的表尾即可确定广义表。</li>
                </ul>
              </li>
              <li>链式存储实现：
                <img src="广义表的链式存储结构.png">
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct _glnode{
  int tag;//tag为0代表原子节点，tag为1代表表结点
  union{
    Elemtype value;原子节点的值
    struct _glnode * hp;//表头指针
  };
  struct _glnode * tp;//表尾指针，对于原子节点来说恒为NULL，若表尾为空表也为NULL；
}GLNode;</code></pre></div></div> 
              </li>

            </ul>
          </li>   


          <li>Tree</li>
            <ul>
              <li>Basic definations:<br>
                node, <abbr title="子树的数量">degree</abbr>, leaf, branch node, <abbr title="节点最大度数">degree of tree</abbr>, level, height, ordered/disordered tree, forest, child, parent, sibling, ancestor, descendant  
              </li>

              <li>Binary tree</li>
                <ul>
                  <li><abbr title="除最深一层右边可能缺少节点，其它各层均满">完全二叉树</abbr>和<abbr title="各层均满的二叉树">满二叉树</abbr></li>
                  <li>二叉树的性质</li>
                    <ul>
                      <li>n<SUB>0</SUB>=n<SUB>2</SUB>+1</li>
                      <li>完全二叉树节点数量和深度关系</li>
                      <li>...</li>
                    </ul>
                  <li>存储结构: 顺序存储结构、二叉链表、三叉链表</li>
                  <ul>
                    <li>顺序结构</li>
                    <li>二叉链表</li>
                    <li>三叉链表</li>
                  </ul>
                  <li>二叉树的遍历: 先序遍历、中序遍历、后序遍历、层序遍历</li>
                  <ul>
                    <li>递归实现</li>
                    <li>非递归实现</li>
                    <ul>
                      <li>先序遍历：<br>利用栈实现，每次出栈一下，出栈元素的rchild和lchild先后入栈</li>
                      <li>中序遍历：<br>利用栈实现，从栈顶元素向左走到尽头，出栈后rchild入栈，然后重复</li>
                      <li>后序遍历：<br>利用栈实现，从栈顶元素向左走到尽头，若栈顶元素rchild和lchild均被访问，出栈；否则rchild入栈，重复。注意：后序遍历非递归算法需要增加visit域</li>
                      <li>层序遍历：<br>利用队列实现，每次出队列一下，出队列元素的lchild和rchild先后入队
                      </li>
                    </ul>
                    <li>一些经典问题</li>
                    <ul>
                      <li>由先序序列和中序序列唯一确定一颗二叉树</li>
                      <li><abbr title="波兰式">前缀式</abbr>、中缀式、<abbr title="逆波兰式">后缀式</abbr>与先序、中序、后序遍历</li>
                    </ul>
                  </ul>
                  <li>线索二叉树</li>
                  <ul>
                    <li>线索二叉树节点结构</li>
                    <li>二叉树的线索化</li>
                    <li>线索二叉树寻找前驱或者后继</li>
                  </ul>
                </ul>

              <li>Tree</li>
              <ul>
                <li>树的存储结构</li>
                <ul>
                  <li>双亲表示法</li>
                  <li>孩子表示法</li>
                  <ul>
                    <li>多重链表</li>
                    <li>孩子链表（图的邻接表）</li>
                    <li>带双亲的孩子链表（双亲表示法+孩子链表）</li>
                  </ul>
                  <li>孩子兄弟表示法</li>
                </ul>
                <li>树的遍历：先根遍历、后根遍历、层序遍历</li>
                <ul>
                  <li><abbr title="先访问根，然后依次先根遍历它的子树">先根遍历</abbr>：<br>借助孩子兄弟表示法和先序遍历实现</li>
                  <li><abbr title="先依次后根遍历根的子树，然后访问根">后根遍历</abbr>：<br>借助孩子兄弟表示法和中序遍历实现</li>
                  <li>层序遍历：<br>借助孩子兄弟表示法和队列实现</li>
                </ul>
              </ul>

              <li>Forest</li>
              以下均是在森林非空的前提下进行的
              <ul>
                <li><abbr title="访问第一颗子树的根，然后先序遍历第一颗子树去掉根后的子树森林，最后先序遍历去掉第一棵树后的森林">先序遍历</abbr>：<br>借助孩子兄弟表示法和先序遍历实现，也可看做依次先根遍历子树</li>
                <li><abbr title="中序遍历第一颗子树去掉根后的子树森林，然后访问第一颗子树的根，最后中序遍历去掉第一棵树后的森林">中序遍历</abbr>：<br>借助孩子兄弟表示法和中序遍历实现，也可看做依次后根遍历子树</li>
              </ul>

              <li>Huffman tree</li>
              <ul>
                <li>基本概念<br><abbr title="带权路径长度最小的二叉树">哈夫曼树</abbr>、树的内部/外部路径长度、带权路径长度</li>
                <li>一些简单的问题</li>
                <ul>
                  <li>包含n个权值的Huffman树总共多少节点？ 2n+1</li>
                  <li>由权值列表画Huffman树</li>
                  <li>最佳判定树 （能否直接套用Huffman算法？ 不一定）<br>成绩判定问题，构建Huffman树必须相邻的成绩区间项相结合，原因：if else语句一次只能判断大于还是小于等于</li>
                  <li>计算外部路径、带权路径？</li>
                </ul>
                <li>Huffman算法 - 构建Huffman树</li>
                <li>Huffman树以及Huffman算法的代码实现<br>推荐的数据结构：结构体数组</li>
              </ul>
            </ul>
          <li>Graph</li>
          <li>Search table</li>   
        </ul>
      </p>
      <br>
      
      <h2><a id="ds-lab">Labs</a></h2>
      <p>to do</p>
      
     


    <br>
    <hr>
    <p><a href="https://shaofengwu123.github.io/study/study-main.html">Back</a></p>
    </section>
  </div>

  <footer>
    <p>Project maintained by <a href="https://github.com/ShaofengWu123">ShaofengWu123</a></p>
    <p>© 2021 GitHub, Inc.</p>
  </footer>
</div>


</body>
</html>






