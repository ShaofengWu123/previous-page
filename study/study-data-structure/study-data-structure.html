<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>Study Data Structure | Shaofeng's Page</title>
<meta property="og:title" content="Shaofeng's Page" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A personal page of Shaofeng Wu." />

<link rel="stylesheet" href="../../css/style-mainpage.css">
<script src="/modernist/assets/js/scale.fix.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

<link rel="shortcut icon" href="../../img/emilia.png"><!--logo-->
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>

  <body>
    <div id="particles-js"></div><!-- particle effect scripts -->
    <script src="../../js/particles.js"></script>
    <script src="../../js/app.js"></script>

  <div id="allpart">
  <div class="wrapper" id="contentpart">
    <header >
      <h1>伍少枫的个人主页</h1>
      <p>Shaofeng's Personal Website</p>
    <p class="view"><a href="https://github.com/ShaofengWu123/ShaofengWu123.github.io">View the Project on GitHub <small></small></a></p>
    <ul>
    <li><a href="https://github.com/ShaofengWu123/ShaofengWu123.github.io">View On <strong>GitHub</strong></a></li>
    </ul>
    </header>
    <section>
      <h1>Data Structure</h1><!-- main title -->

      <ul>
      <li><a href="#ds-outline">Content outline</a></li><!--content list -->
      <li><a href="#ds-lab">Labs</a></li> 
      </ul>
      <hr>

      <h2><a id="ds-outline">Content outline</a></h2>
      <p>
        <ul>
          <li>Linear list/线性表</li>
          <ul>
            <li>基本定义:<br>n(n>=0)个具有相同特性元素组成的有限序列。</li>
            <li>顺序实现：顺序表
            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define LIST_INIT_SIZE 100
#define LIST_INCREMENT 10
typedef struct _sqlist{
    Elemtype* elem;
    int length;
    int size;
}SqList;</code></pre></div></div></li>
            <li>链式实现：链式表 (用一组任意的存储单元存储线性表中元素)
            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define LIST_INIT_SIZE 100
typedef struct _lnode{
    Elemtype* elem;
    struct _lnode * next;  
}Lnode,*LinkList;</code></pre></div></div></li>
            其他的链式表：循环链表、双向循环链表
            <li>典型问题</li>
            <ul>
              <li>顺序表和链式表的比较，例如是否能随机存取和顺序存取</li>
              <li>时间复杂度分析：线性表插入、删除，链式表插入、删除...</li>
              <li>容易搞错的基本操作：清空表、销毁表</li>
            </ul>
          </ul>

          <li><abbr title="仅限定在表尾或者说栈顶进行插入删除操作的特殊线性表，LIFO">Stack</abbr></li> 
          <ul>
            <li>顺序实现：顺序栈
              <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define STACK_INIT_SIZE 100
#define STACK_INCREMENT 10
  typedef struct _sqstack{
      Elemtype* base;
      Elemtype* top;
      int stacksize;//已分配的存储空间
  }SqStack;</code></pre></div></div></li>
            <li>链式实现：链式栈
              <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct _stacknode{
  Elemtype data;
  struct _stacknode * next;
}StackNode;

typedef strrct _linkstack{
  StackNode * top;
}LinkStack;</code></pre></div></div>
            </li>
            <li>基本操作的实现：判断栈空，出栈，入栈，清空栈，销毁栈</li>
            <li>栈的应用
              <ul>
                <li>数制转换计算时储存结果并按顺序输出</li>
                <li>行编辑器的实现</li>
                <li>检测括号匹配</li>
                <li>中缀式求值：
                  <ul>
                    <li>双栈求值（符号栈和数字栈）：<br>&nbsp &nbsp 数字入栈；当前符号优先级小于栈顶符号优先级，处理栈顶符号；当前符号优先级大于栈顶符号优先级，入栈等待；相等，消配对括号</li>
                    <li>中缀式转后缀式（逆波兰式）:<br>&nbsp &nbsp 方法和双栈求值类似，注意碰到右括号时一直出栈直到左括号出栈；逆波兰式求值一次弹出两个数字，此时运算顺序已经排列好了</li>
                  </ul>
                <li>函数调用
                  <ul>
                    <li>调用过程：<abbr title="包括返回地址、局部变量、寄存器。不同语言、不同编译器存在差异">栈帧</abbr>入栈、执行被调函数、出栈、按返回地址继续执行主调函数</li>
                    <li><abbr title="直接或间接调用、定义自己">递归</abbr>
                      <ul>
                        <li>典型问题：汉诺塔、斐波那契数列、阶乘时间空间复杂度（On）</li>
                        <li>提高算法时空性能：尾递归、全局栈存储信息</li>
                      </ul>
                    </li>
                  </ul>
                </li>
                </li>
              </ul>
            </li>
          </ul>

          <li><abbr title="仅限定在一端进行插入，另一端进行删除的特殊线性表，FIFO">Queue</abbr>
            <ul>
              <li>链式实现：链式队列
                <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct _queuenode{
  Elemtype data;
  struct _queuenode * next;
}QueueNode;
                
typedef struct _linkqueue{
  QueueNode * front, *rear;//front指针恒等于head，这样出队方便改变指针指向
}LinkQueue;</code></pre></div></div>
              </li>
              <li>顺序实现：循环队列
                <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define MAXSIZE 100
typedef struct _sqqueue{
  Elemtype *queue;
  int front, rear;//用下标指示队头队尾
}SqQueue;</code></pre></div></div>
                <ul>
                  循环队列留出一个位置用于区分队满和队空
                  <li>入队：rear = (rear+1)%MAXSIZE</li>
                  <li>出队：front = (front+1)%(MAXSIZE-1)</li>
                  <li>判断队满：front==(rear+1)%MAXSIZE</li>
                  <li>判断队空：front==rear</li>
                </ul>
              </li>
            </ul>
          </li> 

          <li><abbr title="0个或多个字符组成的有限序列">String</abbr>
            <ul>
              <li>基本概念<br>&nbsp &nbsp 串值、串长、空串、<abbr title="空格组成的串">空白串</abbr>、子串、<abbr title="从1开始计数，要注意英文字符、数字等为1字节，汉字是2字节">子串的位置</abbr>、串相等、串变量、串常量</li>
              <li>定长顺序存储实现
                <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define MAXSTRLEN 100
typedef struct _sstring{
  unsigned char str[MAXSTRLEN+1];//0位置存储串长
}SString;</code></pre></div></div>
              </li>
              <li>堆分配存储实现
                <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define INITSTRLEN 100
typedef struct _hstring{
  char * ch;
  int length;
}HString;</code></pre></div></div>
              堆分配要注意做操作时要要释放原来的空间，因为原来内存可能被占用
              </li>
              <li>块链存储实现
                <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define BLOCK_SIZE 4
typedef struct _bnode{
  char data[BLOCK_SIZE];//以Bnode为单元，每个单元BLOCK_SIZE个字符，为了提高内存利用率；若不够一个单元，用'@'占位
  struct _bnode * next;
}Bnode;
typedef struct _bstring{
  Bnode * head;
  int strlne;
}BString;</code></pre></div></div>               
              </li>
              <li>串的模式匹配
                <ul>
                  <li>暴力模式匹配 <br> &nbsp &nbsp 时间复杂度O(nm)，即每次都在最后一个出错，实际情况下近似于O(n+m)</li>
                  <li>KMP算法
                    <ul>
                      <li>算法核心思想：对模式串T计算next[]数组，当T的j位置失配，j=next[j]，即按照寻路表向右滑动一定距离</li>
                      <li>求next[]数组
                        <ul>
                          <li>暴力（穷举）法：比较长1,2，...，j-1的子串</li>
                          <li>改进穷举法：先比较长1,2，...，j-1的子串最后一位，相等再比较这两个子串</li>
                          <li>递推法（实现类似KMP算法）
                            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void next3(int next[], SString T) {
  next[0] = T[0];
	next[1] = 0;
	next[2] = 1;
	int i=2, j =1;
  while(i&ltT[0]){
    if(j==0||T[i]==T[j]){i++;j++;next[i]=j}
    else{j=next[j];}
  }
}
</code></pre></div></div>
                          </li>
                        </ul>
                      <li>KMP算法
                        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int KMP_SString(SString S, SString T, int pos, int next[]) {
  if (pos <= 0 || pos > S[0]) { return -1; }//检查pos是否合法
    int j = 1; int i = 1;
    while (j<=T[0]&&i<=S[0]) {
      if (j == 0 || S[i] == T[j]) { i++; j++; }//首个字符失配（此时j=0，是非法的值）或者当前字符匹配，i和j都往后移动一下
      else { j = next[j]; }
    }
    if (j > T[0]) { return i - T[0]; }
    return -1;
  }</code></pre></div></div>
                      </li>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>

          <li>Number set</li>
          <li>Lists</li>   
          <li>Tree</li>
            <ul>
              <li>Basic definations:<br>
                node, <abbr title="子树的数量">degree</abbr>, leaf, branch node, <abbr title="节点最大度数">degree of tree</abbr>, level, height, ordered/disordered tree, forest, child, parent, sibling, ancestor, descendant  
              </li>

              <li>Binary tree</li>
                <ul>
                  <li><abbr title="除最深一层右边可能缺少节点，其它各层均满">完全二叉树</abbr>和<abbr title="各层均满的二叉树">满二叉树</abbr></li>
                  <li>二叉树的性质</li>
                    <ul>
                      <li>n<SUB>0</SUB>=n<SUB>2</SUB>+1</li>
                      <li>完全二叉树节点数量和深度关系</li>
                      <li>...</li>
                    </ul>
                  <li>存储结构: 顺序存储结构、二叉链表、三叉链表</li>
                  <ul>
                    <li>顺序结构</li>
                    <li>二叉链表</li>
                    <li>三叉链表</li>
                  </ul>
                  <li>二叉树的遍历: 先序遍历、中序遍历、后序遍历、层序遍历</li>
                  <ul>
                    <li>递归实现</li>
                    <li>非递归实现</li>
                    <ul>
                      <li>先序遍历：<br>利用栈实现，每次出栈一下，出栈元素的rchild和lchild先后入栈</li>
                      <li>中序遍历：<br>利用栈实现，从栈顶元素向左走到尽头，出栈后rchild入栈，然后重复</li>
                      <li>后序遍历：<br>利用栈实现，从栈顶元素向左走到尽头，若栈顶元素rchild和lchild均被访问，出栈；否则rchild入栈，重复。注意：后序遍历非递归算法需要增加visit域</li>
                      <li>层序遍历：<br>利用队列实现，每次出队列一下，出队列元素的lchild和rchild先后入队
                      </li>
                    </ul>
                    <li>一些经典问题</li>
                    <ul>
                      <li>由先序序列和中序序列唯一确定一颗二叉树</li>
                      <li><abbr title="波兰式">前缀式</abbr>、中缀式、<abbr title="逆波兰式">后缀式</abbr>与先序、中序、后序遍历</li>
                    </ul>
                  </ul>
                  <li>线索二叉树</li>
                  <ul>
                    <li>线索二叉树节点结构</li>
                    <li>二叉树的线索化</li>
                    <li>线索二叉树寻找前驱或者后继</li>
                  </ul>
                </ul>

              <li>Tree</li>
              <ul>
                <li>树的存储结构</li>
                <ul>
                  <li>双亲表示法</li>
                  <li>孩子表示法</li>
                  <ul>
                    <li>多重链表</li>
                    <li>孩子链表（图的邻接表）</li>
                    <li>带双亲的孩子链表（双亲表示法+孩子链表）</li>
                  </ul>
                  <li>孩子兄弟表示法</li>
                </ul>
                <li>树的遍历：先根遍历、后根遍历、层序遍历</li>
                <ul>
                  <li><abbr title="先访问根，然后依次先根遍历它的子树">先根遍历</abbr>：<br>借助孩子兄弟表示法和先序遍历实现</li>
                  <li><abbr title="先依次后根遍历根的子树，然后访问根">后根遍历</abbr>：<br>借助孩子兄弟表示法和中序遍历实现</li>
                  <li>层序遍历：<br>借助孩子兄弟表示法和队列实现</li>
                </ul>
              </ul>

              <li>Forest</li>
              以下均是在森林非空的前提下进行的
              <ul>
                <li><abbr title="访问第一颗子树的根，然后先序遍历第一颗子树去掉根后的子树森林，最后先序遍历去掉第一棵树后的森林">先序遍历</abbr>：<br>借助孩子兄弟表示法和先序遍历实现，也可看做依次先根遍历子树</li>
                <li><abbr title="中序遍历第一颗子树去掉根后的子树森林，然后访问第一颗子树的根，最后中序遍历去掉第一棵树后的森林">中序遍历</abbr>：<br>借助孩子兄弟表示法和中序遍历实现，也可看做依次后根遍历子树</li>
              </ul>

              <li>Huffman tree</li>
              <ul>
                <li>基本概念<br><abbr title="带权路径长度最小的二叉树">哈夫曼树</abbr>、树的内部/外部路径长度、带权路径长度</li>
                <li>一些简单的问题</li>
                <ul>
                  <li>包含n个权值的Huffman树总共多少节点？ 2n+1</li>
                  <li>由权值列表画Huffman树</li>
                  <li>最佳判定树 （能否直接套用Huffman算法？ 不一定）<br>成绩判定问题，构建Huffman树必须相邻的成绩区间项相结合，原因：if else语句一次只能判断大于还是小于等于</li>
                  <li>计算外部路径、带权路径？</li>
                </ul>
                <li>Huffman算法 - 构建Huffman树</li>
                <li>Huffman树以及Huffman算法的代码实现<br>推荐的数据结构：结构体数组</li>
              </ul>
            </ul>
          <li>Graph</li>
          <li>Search table</li>   
        </ul>
      </p>
      <br>
      
      <h2><a id="ds-lab">Labs</a></h2>
      <p>to do</p>
      
     


    <br>
    <hr>
    <p><a href="https://shaofengwu123.github.io/study/study-main.html">Back</a></p>
    </section>
  </div>

  <footer>
    <p>Project maintained by <a href="https://github.com/ShaofengWu123">ShaofengWu123</a></p>
    <p>© 2021 GitHub, Inc.</p>
  </footer>
</div>


</body>
</html>






