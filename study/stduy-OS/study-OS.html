<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>Study | Shaofeng's Page</title>
<meta property="og:title" content="Shaofeng's Page" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A personal page of Shaofeng Wu." />

<link rel="stylesheet" href="../../css/style-mainpage.css">
<script src="/modernist/assets/js/scale.fix.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

<link rel="shortcut icon" href="../../img/emilia.png"><!--logo-->
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <script src="../../js/showhide.js"></script>
  </head>

  <body>
    <div id="particles-js"></div><!-- particle effect scripts -->
    <script src="../../js/particles.js"></script>
    <script src="../../js/app.js"></script>

  <div id="allpart">
  <div class="wrapper" id="contentpart">
    <header >
      <h1>伍少枫的个人主页</h1>
      <p>Shaofeng's Personal Website</p>
    <p class="view"><a href="https://github.com/ShaofengWu123/ShaofengWu123.github.io">View the Project on GitHub <small></small></a></p>
    <ul>
    <li><a href="https://github.com/ShaofengWu123/ShaofengWu123.github.io">View On <strong>GitHub</strong></a></li>
    </ul>
    </header>
    <section>
    <h1>Operating Systems</h1>
      <p>This part inlcudes important topics in OS.</p>
      <ul>
        <li><a href="#os-content">Content outline</a></li>
        <li><a href="#os-question">Questions</a></li>
        <li><a href="#os-ref">Reference</a></li>
      </ul>
      <hr>
      <h2 id="os-content">Content outline</h2>
      <ul>
        <li><a href="#" id="link1">操作系统服务</a>
          <div id="thediv1" style="display:none">
            <img src="./os_services.png" width="750"> 
            <ul>
            <li>方便用户的服务
              <ul>
                <li>用户界面 / User Interface</li>
                <li>程序执行 / Program Execution</li>
                <li>I/O操作 / I/O Operation</li>
                <li>文件系统操作 / File-system Manipulation</li>
                <li>进程间通信 / Communications</li>
                <li>错误检测 / Error Detection</li>
              </ul>
            </li>
            <li>保证效率的服务
              <ul>
                <li>资源分配 / Resource Allocation</li>
                <li>统计 / Accounting</li>
                <li>保护和安全 / Protection and Security</li>
              </ul>
            </li>
            <li>系统调用/System Calls
              <ul>
                <li>概念：操作系统服务的编程接口</li>
                <li>具体实现：API(Application Programming Interface)
                  <p>注意：API不等于系统调用，可以认为API包含系统调用，它相较系统调用更容易使用（参数少），并且在支持相同API的系统上均可以编译执行</p>
                </li>
                <li>系统调用类型
                  <ul>
                    <li>进程控制 / Process Control</li>
                    <li>文件管理 / File Management</li>
                    <li>设备管理 / Device Management</li>
                    <li>信息维护 / Information Maintenance</li>
                    <li>通信 / Communications：例如套接字</li>
                    <li>保护 / Protection</li>
                  </ul>
                </li>
              </ul>
            </li>
            </ul>
          </div>
        </li>

        <li><a href="#" id="link2">操作系统结构</a>
          <div id="thediv2" style="display:none">
          <ul>
            <li>简单结构(Simple Structure)：MS-DOS
              <img src="./ms_dos.png">
              <p>无良好定义的结构，没有模块之分，在最小的空间内提供最多的服务</p>
            </li>
            <li>整体式结构(Monolithic)：UNIX
              <img src="./unix.png">
              <p>系统程序+内核，有限分层</p>
            </li>
            <li>分层结构(Layered Approach)<br>
              <img src="./layered.png">
            </li>
            <li>微内核(Microkernel)：Mach
              <p>将所有非基本部分从内核移除，实现为系统程序或者用户程序，微内核主要功能是使各种服务通信</p>
            </li>
            <li>模块(Modules)：
              <img src="./modules.png">
              <p>核心内核+可加载内核模块，任何一个模块都可以加载任何一个模块且不需要调用消息传递来通信，核心内核只有核心功能以及其他模块加载和通信的相关信息</p>
            </li>
            <li>混合式(Hybrid)：Mac OS X kernel, Windows, Linux</li>
          </ul>
          </div>
        </li>
        <li><a href="#" id="link3">操作系统设计与实现</a>
          <div id="thediv3" style="display:none">
          <ul>
            <li>设计目标 → 没有唯一解决方案
              <ul>
                <li>系统目标和规格：批处理、分时、单用户、多用户、分布式、实时、通用目标</li>
                <li>用户目标：容易使用、学习、可靠、安全、快速</li>
                <li>系统目标：容易设计、实现、维护，灵活、可靠、高效、没有错误</li>
              </ul>
            </li>
            <li><strong>机制(Mechanism)和策略(Policy)的分离</strong>
              <p>机制：怎么做 vs. 策略：做什么<br>例子：机制：需要一个程序优先级机制 策略：CPU密集型程序优先级大于I/O密集型程序<br>优点：机制与策略无关，允许用户创建内核模块等或用户程序来增加策略或者机制。</p>
            </li>
            <li>具体实现：汇编、C、C++</li>
          </ul>
          </div>
        </li>
        <li><a href="#" id="link4">进程的概念</a>
          <div id="thediv4" style="display:none">
          <ul>
            <li>进程(Process)与程序(Program)
              <ul>
                <li>程序：一段静态代码</li>
                <li>进程：代码的执行实例，当一个程序被加载进入内存后，它就成为了进程；进程是动态的</li>
              </ul>
            </li>
            <li>内存中的进程-进程包含的内容<br>
              <img src="./process_in_memory.png"><br>
              用户空间内容：用于进程的运行 vs.内核空间内容：用于进程管理
              <ul>
                <li>文本段：代码</li>
                <li>数据段：全局变量</li>
                <li>栈：临时数据，如函数参数、返回地址、本地变量</li>
                <li>堆：动态分配内存空间</li>
                <li>程序计数器、寄存器内容(在PCB内)</li>
              </ul>
            </li>
            <li>进程状态
              <img src="./process_state.png">
              <ul>
                <li>新的(new)：进程正在被创建</li>
                <li>运行(running)：指令正在被执行，此状态已获得CPU资源，在任何一个CPU上，某时刻只有一个进程在运行</li>
                <li>等待(waiting)：进程正在等待某事件发生，例如I/O结束</li>
                <li>就绪(ready)：进程正在等待被分配给某CPU，此时需要进程调度</li>
                <li>终止(terminated)：进程结束执行</li>
              </ul>
            </li>
            <li>进程控制块-表示、定位、管理进程的数据结构
              <img src="./PCB.png" width="350">
              <ul>
                <li>进程状态</li>
                <li>程序计数器</li>
                <li>CPU寄存器</li>
                <li>CPU调度信息</li>
                <li>内存管理信息</li>
                <li>I/O状态信息，打开文件列表</li>
                <li>记账信息：CPU时间，使用时间，时间界限...</li>
              </ul>
            </li>
          </ul>
          </div>
        </li>
        <li><a href="#" id="link5">进程的用户时间和系统时间</a>
          <div id="thediv5" style="display:none">
          <p>系统运行总时间（性能）= 用户时间 + 系统时间<br>
          注意：
          <ul>
            <li>编写程序时要同时考虑用户时间和系统时间，因为某些系统调用（如<abbr title="暂停进程，等待直到获得数据或资源的一些系统调用">阻塞系统调用</abbr>）会花费相当长的时间</li>
          </ul>
          </p>
          </div>
        </li>

        <li><a href="#" id="link6">进程操作</a>
          <div id="thediv6" style="display:none">
          <p>系统提供的用于进程辨识、创建进程、执行程序、结束进程的工具。</p>
          <ul>
            <li>getpid()
              <p>进入内核空间，查询PCB中的pid，并返回</p>
            </li>
            <li>进程创建
              <p>当系统启动时，创建的第一个进程-init，此进程作为进程树的根，创建更多进程<br>进程树的查看：pstree 命令</p>
              <img src="./pstree_ubuntu.png">
              <ul>
                <li>fork() - "Cell division"
                  <ul>
                    <li>系统修改的内容：pid、运行时间、调用返回值、父进程的孩子指针和子进程的父指针</li>
                    <li>系统没有修改的内容：用户空间进程数据（完全复制，包括代码段、全局变量、局部变量、动态分配空间）、打开文件指针列表、PC等CPU寄存器内容</li>
                  </ul>
                  fork()调用复制PCB并更新子进程PCB
                  <img src="./fork_copying.png">
                  <img src="fork_update.png">
                  fork()调用不对用户空间进程的相关数据做修改，只是复制
                  <img src="./fork_userspace.png">
                </li>
                <li>exec*() - Go to another program
                  <p>execl(program directory,1st arg,2nd arg,...,NULL)</p>
                  <ul>
                    <li>系统修改的内容：用户空间进程数据（包括代码段、全局变量、局部变量、动态分配空间）、PC等CPU寄存器内容</li>
                    <li>系统没有修改的内容：pid、运行时间</li>
                  </ul>
                  exec()系统调用搜索目标程序，更新用户空间进程数据
                  <img src="./exec_userspace.png">
                </li>
              </ul>
            </li>
            <li>wait() - 挂起父进程，等待任意子进程结束，唤醒父进程
              <p>wait()系统调用做的事情：杀死僵尸进程，管理资源 -> 非常重要，原因是：防止僵尸进程堆积而占据资源（pid是有限的），有效的进行系统资源管理
                <ul>
                  <li>设置信号处理服务例程，当收到SIGCHLD信号则对其进行处理。默认情况下，所有的进程都对SIGCHLD没有反应。</li>
                  <li>收到SIGCHLD，移接收并移除SIGCHLD，销毁子进程。</li>
                  <li>移除服务例程，开始无视SIGCHLD，继续执行，返回子进程pid。</li>
                </ul>
              </p>
            </li>
            <li>exit() - 结束进程，并唤醒父进程
              <p>exit()系统调用做的事：让进程成为僵尸进程，回收资源
                <ul>
                  <li>回收大部分的内核空间分配的存储空间</li>
                  <li>回收所有用户空间分配的存储空间</li>
                  <li>子进程发出SIGCHLD通知父进程自己的结束，成为僵尸进程</li>
                </ul>
                Linux系统僵尸进程标签：[defunct]<br>
                Note：特殊情况-孤儿僵尸进程，init进行reparent并定期调用wait()
              </p>
              <img src="./exit_kernel.png">
              <img src="./exit_userspace.png">
            </li>
          </ul>
          </div>
        </li>

        <li><a href="#" id="link7">线程</a>
          <div id="thediv7" style="display:none">
            <ul>
              <li>基本概念：CPU使用的基本单元<br>
              <img src="./thread.png"><br>
              <ul>
                <li>线程包括的内容：tid、PC、寄存器集合、栈</li>
                <li>线程共享的内容：代码段、数据段（全局变量）、动态分配空间以及打开文件、信号等</li>
                <li>线程私有的内容：栈（局部变量）以及寄存器集合</li>
              </ul>
              多线程进程用户空间：<br>
              <img src="./thread_userspace.png">
              </li>
              <li>为什么需要多线程(multi-threading)？
                <ul>
                  <li>进程执行多个任务：多数软件都是多线程的，不同线程负责不同任务。</li>
                  <li>处理相似并发请求：单线程进程处理并发请求会导致处理请求的时间过长。而线程是轻量级的，进程是重量级的，如果创建新进程处理请求，
                    耗费时间资源。故通过多线程，共享资源，高效处理相似（相似表示执行相同任务，会用到相同资源）的并发请求。
                  </li>
                  <li>提高运行效率：单线程进程只能运行在一个CPU上；现代多核计算机包含多CPU，以线程为单位使用CPU，可以让每个进程并行运行在不同处理器上。</li>
                </ul>
              </li>
              <li>多线程优点
                <ul>
                  <li>响应度高<br>
                  多线程让应用程序可以同时执行多个任务(multi-tasking)，当一个线程被阻塞，其他线程可以与用户交互。
                  </li>
                  <li>资源共享<br>
                  线程默认共享所属进程的内存和资源（例如代码段、文件打开列表），一个应用程序可以在同一地址空间有多个不同的活动线程。
                  </li>
                  <li>经济<br>
                  创建进程所需的内存和资源、切换进程所需的时间比创建、切换线程更昂贵。
                  </li>
                  <li>多处理器体系利用：<br>
                  单线程进程只能运行在一个CPU上；现代多核计算机包含多CPU，以线程为单位使用CPU，可以让每个进程并行运行在不同处理器上。
                  </li>
                </ul>
              </li>
              <li>多线程的挑战
                <ul>
                  <li>区分同时运行的不同的任务</li>
                  <li>均分、平衡不同线程的工作量</li>
                  <li>数据分发</li>
                  <li>数据的互斥(mutual exclusion)与同步(synchronization)</li>
                  <li>测试和debug</li>
                </ul>
              </li>
              <li>多线程模型
                <p>用户线程：受内核支持而无须内核管理<br>
内核线程：由操作系统直接支持和管理，可以认为是使用CPU的基本单元
                </p>
                <ul>
                  <li>多对一模型：许多用户级线程映射到一个内核级线程（也可认为是一个进程结构）
                    <ul>
                      <li>优点：效率更高（线程管理由线程库在用户空间完成）、内核更容易实现</li>
                      <li>缺点：
                        <ul>
                          <li>一个用户线程阻塞将导致整个进程阻塞</li>
                          <li>由于任意时刻只有一个线程能访问内核，所以多个用户线程实际上不能并行运行在多处理器上</li>
                        </ul>
                      </li>
                    </ul>
                    例子：旧UNIX，Green thread
                  </li>
                  <li>一对一模型：每个用户级线程映射到一个内核级线程结构或者进程结构
                    <ul>
                      <li>优点：并发程度高、某线程阻塞不会阻塞其他线程</li>
                      <li>缺点：限制了系统支持的线程数量（每创建一个用户线程就要创建一个相应的内核线程）</li>
                    </ul>
                    例子：Linux，Windows
                  </li>
                  <li>多对多模型：用户线程映射到相同数量或更少数量的内核线程上<br>
                    优点：并发性高，虽然相较一对一模型没有增加并发性（内核一次还是只能调度一个线程）；可以创建任意多用户线程。
                  </li>
                </ul>
              </li>
              <li>多线程引起的一些问题
                <ul>
                  <li>fork()和exec()的语义
                    <ul>
                      <li>fork()语义：
                        <ul>
                          <li>新进程复制所有线程。这种情况应该适用于fork()之后不调用exec()的应用。</li>
                          <li>新进程只复制调用线程。这种情况应适用于fork()之后调用exec()的应用</li>
                        </ul>
                      </li>
                      <li>exec()语义</li>
                    </ul>
                  </li>
                  <li>线程取消</li>
                  <li>信号处理</li>
                  <li>线程特定数据</li>
                  <li>线程池</li>
                </ul>
              </li>
            </ul>
          </div>
        </li>
      </ul>

      <h2 id="os-question">Questions</h2>
      <p>此部分包含了一些经典的OS的问题以及部分参考回答，题目前标注了该问题知识点所处的章节</p>
      <ul>
        <li>(1)从用户的角度来看，操作系统的功能是什么？从系统的角度来看，操作系统的功能是什么？</li>
        <li>(1)操作系统提供的服务有哪九种？分别具体指什么？</li>
        <li>(1)用户空间和内核空间指什么？为什么要做这样的区分？</li>
        <li>(1)Dual mode是什么？为什么要区分用户模式和内核模式？进程的用户时间和系统时间指什么？</li>
        <li>(1)Multiprogramming和Multitasking分别指什么？它们的作用或者说目的是什么？</li>
        <li>(1)系统调用是什么？API与系统调用的关系是什么？</li>
        <li>(1)操作系统的结构有哪几种？它们各自的优缺点是什么？Linux,MacOS,Windows是什么类型的？</li>
        <li>(1)</li>
        <br>
        <li>(3)为什么说程序是静态的，进程是动态的？</li>
        <li>(3)进程包含了哪些内容？对于一个进程而言，存储在用户空间和内核空间的内容分别是什么？用户/内核空间存储的内容对于进程的意义分别是什么？</li>
        <li>(3)进程的状态有哪些？这些状态的状态转换图是什么样的？</li>
        <li>(3)PCB包含了哪些内容？PCB的作用是什么？</li>
        <li>(3)代码段相同的进程是否一定是同一个进程？或者说两个不同的进程能否运行同一个程序？同一进程能否运行不同的程序？</li>
        <li>(3)在任意时刻，一个核上能否运行多个程序？如果不能，为什么我们在使用个人电脑时，可以同时运行多个程序？</li>
        <li>(3)程序能否作为其他程序运行的环境？请举一个例子？</li>
        <li>(3)操作系统用什么标识进程？</li>
        <li>(3)子进程和父进程指什么？它们之间在资源、运行顺序以及地址空间上有什么关系？进程树是什么？操作系统怎么处理孤儿进程？为什么当终端关闭后，后台进程可以继续运行？对于windows和linux系统，进程树会有多棵么？</li>
        <li>(3)说一说fork()系统调用如何工作？通过fork()创建的子进程是父进程的一个拷贝么？如果不是，它们的异同是什么？</li>
        <li>(3)说一说exec()系统调用如何工作？exec()调用与普通函数调用的区别是什么？exec()系统调用为什么不会回到原来的进程继续执行？execl()调用后，“新”的进程保留了原进程的哪些部分？</li>
        <li>(3)wait()系统调用对于程序员来说作用是什么？对于系统呢？若父进程对应的代码段里存在wait()，那么父进程是否一定会被阻塞(考虑进程执行的顺序？)？父进程收到SIGCHLD后如何进行处理？wait()的返回值是什么？</li>
        <li>(3)如果在父进程调用wait()前，子进程已经调用exit()，这是否会对wait()的执行产生影响？</li>
        <li>(3)exit()系统调用为什么一般和wait()配合使用？僵尸进程是什么？exit()系统调用过程中，内核做了什么工作？exit()系统调用后，进程进入terminated状态，terminated状态的作用是什么？</li>
        <li>(3)僵尸进程的作用是什么，或者说exit()调用为什么不直接杀死进程并销毁PCB而是让进程变为僵尸进程？僵尸进程的PCB包含哪些内容？当子进程结束时，父进程收到什么信号？</li>
        <li>(3)在什么情况下进程会成为僵尸进程？从main()函数返回或者进程异常结束会么？僵尸进程什么时候结束？</li>
        <li>(3)孤儿僵尸进程会发生在什么情况下？如何解决这个问题？</li>
        <br>
        <li>(4)线程是什么？线程和进程之间的关系是什么样的？同属一个进程的线程哪些数据资源共享，哪些部分不共享？</li>
        <li>(4)什么是线程函数？线程函数是否会返回到其调用者？</li>
        <li>(4)为什么要使用多线程而不是多个进程即可？</li>
        <li>(4)使用多线程的优点体现在哪些方面？</li>
        <li>(4)用户线程和内核线程是什么？</li>
        <li>(4)线程模型有哪三种？多对一模型的优缺点是什么？一对一模型呢？</li>
        <li>(4)线程池是什么？线程池的好处有什么？</li>
      
      </ul>

      <h2 id="os-ref">Reference</h2>
      <ul>
        <li>中科大操作系统课程ppt</li>
      </ul>
    <br>
    <hr>
    <p><a href="../study-main.html">Back</a></p>
    </section>
  </div>
  
  <footer>
    <p>Project maintained by <a href="https://github.com/ShaofengWu123">ShaofengWu123</a></p>
    <p>© 2021 GitHub, Inc.</p>
  </footer>
</div>


</body>
</html>