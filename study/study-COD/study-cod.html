<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>Study | Shaofeng's Page</title>
<meta property="og:title" content="Shaofeng's Page" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A personal page of Shaofeng Wu." />

<link rel="stylesheet" href="../../css/style-mainpage.css">
<script src="/modernist/assets/js/scale.fix.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

<link rel="shortcut icon" href="../../img/emilia.png"><!--logo-->
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <script src="../../js/showhide.js"></script>
  </head>

  <body>
    <div id="particles-js"></div><!-- particle effect scripts -->
    <script src="../../js/particles.js"></script>
    <script src="../../js/app.js"></script>

  <div id="allpart">
  <div class="wrapper" id="contentpart">
    <header >
      <h1>伍少枫的个人主页</h1>
      <p>Shaofeng's Personal Website</p>
    <p class="view"><a href="https://github.com/ShaofengWu123/ShaofengWu123.github.io">View the Project on GitHub <small></small></a></p>
    <ul>
    <li><a href="https://github.com/ShaofengWu123/ShaofengWu123.github.io">View On <strong>GitHub</strong></a></li>
    </ul>
    </header>
    <section>
    <h1>Computer Organization and Design</h1>
      <p>This part inlcudes important topics in computer organization and design.</p>
      <ul>
        <li><a href="#cod-content">Content</a></li>
        <li><a href="#cod-question">Questions</a></li>
        <li>Reference</li>
      </ul>

      <h2 id="cod-content">Content</h2>
      <p>This part includes important content in COD. This is a simple outline.</p>
      <ul>
        <li><a href="#" id="link2">计算机系统概论</a>
          <div id="thediv2" style="display:none">
          <ul>
            <li><a href="#" id="link2_1">计算机系统概述</a>
            <div id="thediv2_1" style="display:none">
            <ul>
              <li>计算机系统简介
                <ul>
                  <li>计算机的简单分类：专用机(嵌入式)、通用机(包括工作站、...)</li>
                  <li>计算机系统：由软件+硬件构成的复杂的自动化电子设备</li>
                  <li>软、硬件关系：逻辑等价性
                    <ul>
                      <li>硬件软化</li>
                      <li>软件硬化</li>
                      <li><attr title="将一些功能固化地保存在只读存储器中">软件固化</attr></li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>计算机层次结构</li>
              <img src="./layers.png">
            </ul>
            </div>
            </li>
            <li><a href="#" id="link2_2">☆计算机基本组成</a>
              <div id="thediv2_2" style="display:none">
              <ul>
                <li>硬件组成
                  <ul>
                    <li>五大部件
                      <ul>
                        <li>运算器/ALU：<attr title="累加寄存器(结果和第二个操作数)、乘商寄存器、操作数寄存器"></attr>ACC、MQ、X</li>
                        <li>存储器：MAR、MDR</li>
                        <li>控制器：PC、IR、CU</li>
                        <li>输入/输出设备</li>
                      </ul>
                      <img src="./计算机结构简图.png">
                    </li>
                    <li>冯诺依曼结构、哈佛结构、现代计算机结构
                      <ul>
                        <li>冯诺依曼结构：运算器为中心的</li>
                        <img src="./冯诺依曼结构.png">
                        <li>哈佛结构：指令与数据分开存放，并使用独立的总线</li>
                        <img src="./哈佛结构.png">
                        <li>现代计算机结构：存储器为中心的</li>
                        <img src="./现代计算机.png">
                      </ul>
                    </li>
                    <li>计算机组成与计算机体系结构
                      <ul>
                        <li>计算机体系结构：概念性的机器结构与功能特性</li>
                        <li>计算机组成原理：计算机体系结构的逻辑实现</li>
                        <li>举例：计算机有哪些指令属于计算机体系结构问题，指令如何实现属于计算机组成原理问题</li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li>软件组成
                  <ul>
                    <li>系统软件</li>
                    <li>应用软件</li>
                  </ul>
                </li>
              </ul>
              </div>
            </li>
            <li><a href="#" id="link2_3"><strong>☆计算机硬件性能指标</strong></a>
              <div id="thediv2_3" style="display:none">
              <ul>
                <li><attr title="CPU一次能处理的数据位数，一般和CPU内寄存器、运算部件、数据总线宽度一样">机器字长</attr></li>
                <li>存储容量相关
                  <br>存储字长、存储地址位数、存储容量、<attr title="数据总线宽度">数据字长</attr>、存储器带宽、<attr title="只是表示固定位数的单位，即存储器按字/字节寻址中提到的字、字节">字、字节</attr>
                </li>
                <li>运行速度相关
                  <br>CPI、MIPS、MFLOPS、IC、<attr title="主频、时钟频率">f</attr>、<attr title="时钟周期">T<sub>CLK</sub></attr>、<attr title="程序总时钟周期数">CLK</attr>、<attr title="程序运行消耗总的CPU时间">T<sub>CPU</sub></attr>
                  、响应时间、吞吐率、可靠性、可用率
                  <ul>
                    <li>f、CPI、IC反映的问题
                      <ul>
                        <li>f：制作工艺、硬件实现逻辑</li>
                        <li>CPI：硬件实现逻辑、指令集结构</li>
                        <li>IC：指令集结构、编译技术</li>
                      </ul>
                    </li>
                    <li>注意
                      <ul>
                        <li>MIPS和MFLOPS计算都使用程序运行的总时间，对于MFLOPS不是只用浮点运算时间</li>
                        <li>当有多种指令，每种指令有自己的CPI时，加权平均计算总的CPI；当指令系统经过修改之后，计算平均CPI时要注意这个时候IC是否变化</li>
                      </ul>
                    </li>
                  </ul>
                  
                </li>
              </ul>
              </div>
            </li>
            <li><a href="#" id="link2_4">计算机/CPU发展历史</a>
              <div id="thediv2_4" style="display:none">
              <ul>
                <li>计算机分代</li>
                <li>计算机设计面临挑战
                  <ul>
                    <li>线延迟墙、频率墙、功耗墙等：与制作工艺越来越精密有关</li>
                    <li>存储墙、I/O墙：CPU频率与存储设备、I/O设备不匹配</li>
                    <li>解决的技术</li>
                    <img src="./计算机发展挑战.png">
                  </ul>
                </li>  
              </ul>
              </div>
            </li>
            <li><a href="#" id="link2_5"><strong>☆性能评估方法</strong></a>
              <div id="thediv2_5" style="display:none">
              <ul>
                <li>芯片制作成本
                  <ul>
                    <li>芯片制作流程
                      <br>版图设计 -> 备片 -> 光刻成像 -> 掺杂、金属化、钝化 -> 切割 -> 测试 -> 封装
                    </li>
                    <li>芯片成本 = (NRE+单片集成电路成本*芯片数)/芯片数
                      <br>注：NRE费用为单次投片费用，芯片销量高，则成本下降
                      <ul>
                        <li>单片集成电路成本 = (晶片成本 + 晶片测试成本 + 封装成本)/最终成品率
                          <ul>
                            <li>晶片成本 = 晶圆成本 / (每块晶圆上晶片数 * 晶片成品率)
                              <ul>
                                <li>每块晶圆上晶片数 = 晶圆面积/晶片面积 - π*晶圆直径/(2*晶片面积)<sup>0.5</sup>
                                <br>注：即全部的减去边沿上的
                                </li>
                                <li>晶片成品率 = 晶圆成品率*(1+(疵点密度*晶片面积/a))<sup>-a</sup></li>
                              </ul>
                            </li>
                          </ul>
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li>CPU时间计算：T<sub>CPU</sub> = T<sub>CLK</sub>*CLK = T<sub>CLK</sub>*CPI*IC</li>
                <li>Amdahl定律
                  <br>可改进比例f<sub>e</sub>、部件加速比S<sub>e</sub>与总加速比S的关系 -> 只对计算机系统一部分做性能改进，则改进越多效果越小，系统加速比不超过1/(1-f<sub>e</sub>)
                  <br>S = 1/(1-f<sub>e</sub> + (f<sub>e</sub>/S<sub>e</sub>))
                </li>
              </ul>
              </div>
            </li>
          </ul>
          </div>  
        </li>

        <li><a href="#" id="link3">指令系统</a>
          <div id="thediv3" style="display:none">
          <ul>
            <li><a href="#" id="link3_1">指令系统概述</a>
            <div id="thediv3_1" style="display:none">
            <ul>
              <li>指令系统发展
                <ul>
                  <li>指令与指令系统
                    <ul>
                      <li>指令：计算机执行某种操作的命令
                        <ul>
                          <li>微指令：微程序级命令，例如取地址、译码，属于硬件</li>
                          <li>宏指令：机器指令集合，属于软件</li>
                          <li>机器指令：通常所说的指令，介于微指令和宏指令之间</li>
                        </ul>
                      </li>
                      <li>指令系统：某计算机所有机器指令的集合</li>
                    </ul>
                  </li>
                  <li>指令系统发展的兼容性
                    <ul>
                      <li>向前兼容和向后兼容：某时期机器编制的程序可以不加修改地运行于早于/晚于它出现的机器</li>
                      <li>向上兼容和向下兼容：某时期机器编制的程序可以不加修改地运行于比它高档/比他低档的机器</li>
                      <li>兼容的方法：
                        <br>多数指令集是向后兼容的，方法是新的指令系统包含旧机器所有指令
                      </li>
                    </ul>
                  </li>
                  <a href="https://zhuanlan.zhihu.com/p/28195702">兼容性参考</a>
                  <li>指令系统复杂化与精简
                    <ul>
                      <li>CISC</li>
                      <li>RISC</li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>指令系统性能要求
                <ul>
                  <li>完备性</li>
                  <li>有效性：访存、执行高效</li>
                  <li>规整性</li>
                  <li>兼容性：向上、后兼容</li>
                </ul>
              </li>
              <li>编程语言与硬件关系
                <ul>
                  <li>高级语言：与指令集无关，硬件结构对其透明，不能直接访问硬件(C,C++...)</li>
                  <li>低级语言：与指令系统密切相关，需要借助汇编器转化为机器语言以运行(机器只能识别运行机器语言)</li>
                </ul>
              </li>
            </ul>
            </div>
            </li>
            <li><a href="#" id="link3_2">指令格式</a>
              <div id="thediv3_2" style="display:none">
              <ul>
                <li>指令格式：操作码字段+地址码字段
                  <ul>
                    <li>操作码：指明指令要完成的操作
                      <br>操作码长度：反映机器操作种类数量
                      <ul>
                        <li>定长操作码
                          <ul>
                            <li>设计方法：操作码长度固定，集中在某一字段</li>
                            <li>优点：便于硬件设计，便于译码</li>
                          </ul>
                        </li>
                        <li>变长操作码/扩展操作码
                          <ul>
                            <li>设计方法：操作码长度随指令中地址数变化</li>
                            <li>优点：有利于压缩操作码长度</li>
                            <li>设计原则：使用频率高的指令应安排在操作码短的指令，有利于译码</li>
                            <li>注意事项：
                              <br>短操作码可能会占用长操作码的前几位，导致可用的长操作码减少（防止混淆）
                            </li>
                          </ul>
                        </li>
                      </ul>
                    </li>
                    <li>地址码：指明源操作数地址、结果地址、下一条指令地址
                      <ul>
                        <li>零地址指令</li>
                        <li>一地址指令</li>
                        <li>二地址指令</li>
                        <li>三地址指令</li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li>指令字长
                  <ul>
                    <li>概念：指令中二进制位位数</li>
                    <li>按与机器字长关系分
                      <ul>
                        <li>单字长指令</li>
                        <li>半字长指令</li>
                        <li>双/多字长指令：为了增加地址位，但是CPU需要多次访存</li>
                      </ul>
                    </li>
                    <li>按指令字长本身是否可变
                      <ul>
                        <li>等长指令结构</li>
                        <li>变长指令结构：例如有普通指令和压缩指令</li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li>指令助记符
                  <br>用字母表示指令，可以认为是汇编代码，利用汇编器从助记符到二进制操作码
                </li>
              </ul></div>
            </li>
            <li><a href="#" id="link3_3">操作数与操作类型</a>
              <div id="thediv3_3" style="display:none">
              <ul>
                <li>操作数类型：地址、数值、字符、逻辑数据等</li>
                <li><strong>数据在存储器内存放方式</strong>
                <ul>
                  <li>基本存储单元：字节</li>
                  <li>访问方式：按字节访问、按字访问、按半字访问、按双字访问</li>
                  <li>边界对齐
                    <ul>
                      <li>问题：某多字节数据存储时，如何选择存放区域？</li>
                      <li>对齐方式：原则是保证该数据之前和之后的地址空间都能正好完整存放同一长度的数据即可(例子如下图)，另外如果不满字节、半字、字、双字，那么要填充空白字节</li>
                      <img src="./地址对齐.png">
                      <li>意义：确保CPU访存速度</li>
                    </ul>
                  </li>
                  <li>字节顺序
                    <ul>
                      <li>问题：多字节数据按字节存储，各字节顺序如何？</li>
                      <li>存放方式：大/小尾端 -> 低位字节在高/低地址，尾即指低位字节(0x0123例子如下图)</li>
                      <img src="./小尾端.png">
                    </ul>
                  </li>
                </ul>
                </li>
                <li>操作类型
                  <ul>
                    <li>数据传送操作：LOAD,STORE,MOVE,PUSH,POP...</li>
                    <li>算数逻辑操作</li>
                    <li>移位操作：可代替简单的乘除法</li>
                    <li>转移跳转操作
                      <ul>
                        <li>无条件跳转</li>
                        <li>条件转移</li>
                        <li>过程调用与返回：调用者保存、被调用者保存</li>
                        <li>陷阱：中断，可能是CPU隐含指令，在意外发生时执行；也有提供给用户使用的，用于完成系统调用等</li>
                        <li>输入输出操作：适用于I/O独立编址机器</li>
                        <li>其他指令：停机、NOP等</li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
              </div>
            </li>
            <li><a href="#" id="link3_4">寻址方式</a>
              <div id="thediv3_4" style="display:none">
              <ul>
                <li>指令/数据寻址关系
                  <br>冯诺依曼结构两者交替(数据和指令放在一起)，哈佛结构可同时
                </li>
                <li>指令寻址
                  <ul>
                    <li>顺序寻址：PC+1</li>
                    <li>跳跃寻址：转移类指令执行</li>
                  </ul>
                </li>
                <li>数据寻址
                  <ul>
                    <li>基本概念
                      <ul>
                        <li>形式地址A：指令地址码字段所表示地址，通常不是真实地址</li>
                        <li>有效地址EA：相对于形式地址，是真实地址</li>
                        <li>寻址特征：指示寻址方式</li>
                        <li>数据寻址：由形式地址，通过寻址特征变换成有效地址</li>
                      </ul>
                    </li>
                    <li>寻址方式
                      <br>注意，其中偏移寻址分为三种
                      <ul>
                        <li>相对寻址：EA = A + (PC) -> 程序时间空间局部性以及程序相对位置与绝对位置无关</li>
                        <li>基址寻址：
                          <ul>
                            <li>方法：寄存器中含有一个主存地址，指令中的形式地址A表示相对于该地址的偏移量</li>
                            <li>特点：基址寄存器的内容通常由操作系统或管理程序确定，在程序执行过程中<strong>不可变</strong>，可变的是形式地址A</li>
                            <li>用途：扩大基址寄存器位数从而扩大寻址范围、为程序透明地分配空间、实现段寻址</li>
                          </ul>
                        </li>
                        <li>变址寻址
                          <ul>
                            <li>方法：指令中的形式地址A表示一个主存地址，寄存器中含有相对于该地址的偏移量</li>
                            <li>特点：变址寄存器的内容由用户设定，在程序执行过程中可变，但形式地址A的内容是<strong>不可变</strong>的</li>
                            <li>用途：数字操作、循环等</li>
                          </ul>
                        </li>
                      </ul>
                    </li>
                    <br><img src="./寻址方式1.png"><br><img src="./寻址方式2.png">
                    <li>寻址方式研究意义：硬件和指令系统设计、汇编程序效率的提高...</li>
                  </ul>
                </li>
              </ul>
              </div>
            </li>
            <li><a href="#" id="link3_5">CISC和RISC</a>
              <div id="thediv3_5" style="display:none">
              <ul>
                <li>CISC与RISC对比</li>
                <img src="RISC-CISC.png">
                <br>其他的一些对比
                <table>
                  <thead>
                    <tr>
                      <th style="text-align: left">对比项</th>
                      <th style="text-align: left">CISC</th>
                      <th style="text-align: left">RISC</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td style="text-align: left">全称</td>
                      <td style="text-align: left">Complicated Instruction Set Computer</td>
                      <td style="text-align: left">Reduced Instruction Set Computer</td>
                    </tr>
                    <tr>
                      <td style="text-align: left">采用的技术</td>
                      <td style="text-align: left">扩展操作码、变长指令、多种寻址方式</td>
                      <td style="text-align: left">流水线、超标量</td>
                    </tr>
                    <tr>
                      <td style="text-align: left">寄存器数量</td>
                      <td style="text-align: left">少</td>
                      <td style="text-align: left">多</td>
                    </tr>
                    <tr>
                      <td style="text-align: left">缺点</td>
                      <td style="text-align: left">指令集庞大，设计新一代指令考虑兼容不方便；硬件设备复杂，处理器设计周期长；大部分指令只有很少的时候会用到</td>
                      <td style="text-align: left">汇编程序编写复杂，完成特殊功能比较慢</td>
                    </tr>
                    <tr>
                      <td style="text-align: left">出现原因</td>
                      <td style="text-align: left">早期计算机主频低，元件昂贵，运算慢</td>
                      <td style="text-align: left">集成电路技术发展，并且简单指令实际上占程序的大部分</td>
                    </tr>
                  </tbody>
                </table>
                <li><a href="https://zhuanlan.zhihu.com/p/346864380">参考</a></li>
              </ul>
              </div>
            </li>
            <li><a href="#" id="link3_6">指令系统设计与举例</a>
              <div id="thediv3_6" style="display:none">
              <ul>
                <li>MIPS</li>
                <li>x86(CISC)</li>
                <li>RISC-V</li>
                <img src="./RISC-V_ISA.png">
                <img src="RISC-V1.png"><img src="RISC-V2.png">
              </ul>
              </div>
            </li>
          </ul>
          </div>  
        </li>


        <li><a href="#" id="link4">RISC-V处理器设计</a>
          <div id="thediv4" style="display:none">
          <ul>
            <li><a href="#" id="link4_1">单周期CPU</a>
              <div id="thediv4_1" style="display:none">
              <br>单周期CPU本质上是有限状态机
              <br>注：图中未添加jal相关数据通路，其数据通路添加PC+4到寄存器写数据以及Jump到PCSrc控制
              <img src="./cpu_single.png">
              <br>典型问题
              <ul>
                <li>时钟周期(机器周期) = 指令周期</li>
                <li>时钟周期确定/关键路径确定/主频计算</li>
              </ul>
              </div>
            </li>
            <li><a href="#" id="link4_2">多周期CPU</a>
              <div id="thediv4_2" style="display:none">
              <ul>
                <li>多周期含义：定长机器周期，不定长指令周期，部件复用，中间结果保存</li>
                <li>多周期各周期任务
                  <br>取指->译码->执行->访存->写回
                </li>
                <li>多周期数据通路(MIPS)
                  <br>注意，由于MIPS的J型指令是通过PC高四位加指令中26位地址左移2位(每条指令4byte，而RISC-V有压缩指令，所以左移1位)得到的，而RISC-V的UJ型指令是通过PC+offset-left-shift得到的，因此RISC-V的无条件跳转指令应该在ID计算目标地址，在EX将ALUOut给PC
                </li>
                <img src="./MIPS多周期.png">
                <li>多周期有限状态机(MIPS)</li>
                <img src="./多周期有限状态机.png">
                <img src="./多周期有限状态机2.png">
              </ul>
              </div>
            </li>
            <li><a href="#" id="link4_3">流水线CPU</a>
              <div id="thediv4_3" style="display:none">
              <ul>
                <li>流水线性能评价：吞吐率、实际吞吐率(任务量/实际运行时间)、最大吞吐率(流水线稳定状态吞吐率)、加速比、最大加速比、效率
                  <ul>
                    <li>吞吐率
                      <ul>
                        <li>最大吞吐率：TPmax = 1/t<sub>0</sub>，t<sub>0</sub>即流水线各段时间，假设相等</li>
                        <li>实际吞吐率：
                          <br>T<sub>流水</sub> = mt<sub>0</sub>+(n-1)t<sub>0</sub>
                          <br>TP = n/T<sub>流水</sub>
                        </li>
                        <li>各段时间不等时，最大吞吐率取决于最长流水段(瓶颈段)，实际吞吐率为第一个任务所用总时间加(n-1)tmax，因为后续任务在瓶颈段等待</li>
                      </ul>
                    </li>
                    <li>加速比
                      <ul>
                        <li>最大加速比：m，即流水段数</li>
                        <li>实际加速比：nmt<sub>0</sub>/T<sub>流水</sub></li>
                      </ul>
                    </li>
                    <li>效率
                      <br>E = 实际加速比/最大加速比 = nt<sub>0</sub>/T<sub>流水</sub> = 面积比 = TPt<sub>0</sub>，填充时间、流水段不均匀导致效率下降，提高效率也会提高吞吐率
                    </li>
                  </ul>
                </li>
                <li>五段流水RISC-V CPU的基本结构</li>
                <img src="./cpu_pipeline.png">
                <li>结构冒险
                  <ul>
                    <li>哈佛结构(数据和指令内存分离)</li>
                    <li>寄存器堆写优先</li>
                    <li>瓶颈段
                      <br>虽然没有真正的结构冒险，但是会破坏流水段均匀性 -> 细分瓶颈/并行重复瓶颈段
                    </li>
                  </ul>
                </li>
                <li>数据冒险
                  <ul>
                  <li>分类：写后读(RAW)、写后写(WAW)、读后写(WAR)
                    <br>谁会出现？写后读  谁不会？写后写，读后写
                  </li>
                  <li>数据前递/forwarding
                    <ul>
                      <li>前递路径
                        <br>从 MEM,WB 前递到 EX，还有别的么？
                        <ul>
                          <li>可能有 MEM,WB 前递到 ID (分支提前)</li>
                          <li>可能有 WB 前递到 MEM (lw-sw且rd和rs2冲突)</li>
                        </ul>
                      </li>
                      <li>判断逻辑？
                        <br>目标寄存器==要用的寄存器并且该段RegWrite有效</li>
                    </ul>
                    <br>
                  </li>
                  <li>一般的数据冒险
                    <br>由数据前递解决 -> forward unit判断数据冒险，前递MEM和WB段数据(两者同时冒险那么MEM优先) 
                  </li>
                  <li>load-use数据冒险
                    <br>发生在：load在EX段，use指令在ID段，那么将IF,ID段冻结一个周期(流水线互锁) -> 锁定PC和IF/ID.regs，清除ID/EX.regs -> 然后由前递处理
                    <br>load-use包括？
                    <ul>
                      <li>load-R：例如lw rd,offset(rs1) -> add rd,rs1,rs2</li>
                      <li>load-I：例如lw rd,offset(rs1) -> add rd,rs1,imm</li>
                      <li><strong>lw-sw？？？</strong>
                        <br>lw <strong>x1</strong>,offset(x2) -> sw x3,offset(<strong>x1</strong>) ？ 实际上是load-I，是load-use，要停顿流水线
                        <br>lw <strong>x1</strong>,offset(x2) -> sw <strong>x1</strong>,offset(x3) ？ 可以是，也可以不是。认为是那么就是load-R,rs2冲突；认为不是，sw最晚MEM段才用，可以用数据前递解决，不用停顿流水线，不是真正意义上的load-use
                      </li>
                    </ul>
                  </li>
                  </ul>
                </li>
                <li>控制冒险
                  <ul>
                  <li>分支提前(降低分支的延迟)
                    <br>分支提前到IF -> 新的数据相关，额外的前递
                  </li>
                  <li>延迟分支(编译调度)
                    <ul>
                      <li>从前调度：被调度指令与分支结果无关</li>
                      <li>从目标处调度：被调度指令与分支结果无关，并且不会在分支失败时导致顺序执行调度指令、失败处指令发生错误</li>
                      <li>从失败处调度：被调度指令与分支结果无关，并且不会在分支成功时导致顺序执行调度指令、成功处指令发生错误</li>
                    </ul>
                  </li>
                  <li>分支预测
                    <ul>
                      <li>静态分支预测：投机执行
                      <ul>
                        <li>总是预测分支失败</li>
                        <li>总是预测分支成功</li>
                        <li>向后(指PC小方向)分支预测成功，向前分支预测失败(适合嵌套循环)</li>
                      </ul>
                    </li>
                    <li>动态分支预测
                      <ul>
                        <li>一位动态预测：根据上次结果预测这次结果，预测失败立刻修改分支结果</li>
                        <li>两位缓冲动态预测：两次预测失败才修改分支预测结果</li>
                      </ul>
                    </li>
                    </ul>
                  </li>
                  </ul>
                </li>
                <li>流水线多发技术
                  <br>目标：简单标量流水线，通过减少流水线停顿 -> IPC=1(CPI=1) &nbsp &nbsp 多发技术 -> IPC>1
                  <ul>
                    <li>超标量技术
                      <ul>
                        <li>实现：多个寄存器端口、指令译码电路、总线、功能部件，并行发射和执行多条不相关指令。指令并行化需要由编译器决定。</li>
                        <li>注意事项：不能改变指令逻辑顺序</li>
                      </ul>
                    </li>
                    <li>超流水线/深度流水线
                      <ul>
                        <li>实现：细分流水段，一个周期内流水段被多次使用。优化由编译器完成。</li>
                        <li>注意事项：不能改变指令逻辑顺序</li>
                      </ul>
                    </li>
                    <li>超长指令字
                      <ul>
                        <li>实现：并行方法与超标量类似，但是超标量指令来自标准值指令流，超长指令字在编译时发掘指令并行性，然后组合指令成为超长指令，指挥多个功能部件运行。</li>
                        <li>注意事项：对编译器、Cache容量要求更高</li>
                      </ul>
                    </li>
                  </ul>
                  <img src="./流水线多发技术.png">
                </li>
              </ul>
            </div>
            </li>
            <li> <a href="#" id="link4_4">三种CPU实现的对比</a>
              <div id="thediv4_4" style="display:none">
                <img src="CPU对比.png">
              </div>
            </li>
          </ul>
          </div>
          <a href="#" id="link4_5"></a> <div id="thediv4_5" style="display:none"></div><a href="#" id="link4_6"></a> <div id="thediv4_6" style="display:none"></div>
        </li>
       
      
        <li><a href="#" id="link5">中断</a>
          <div id="thediv5" style="display:none">
            <ul>
            <li><a href="#" id="link5_1">中断的基本概念</a>
              <div id="thediv5_1" style="display:none">
              <ul>
                <li>中断：暂停当前程序执行，转而执行其他程序，执行完成后恢复被中断程序执行</li>
                <li>中断的作用
                  <ul>
                    <li>异常</li>
                    <li>I/O</li>
                    <li>并发</li>
                    <li>服务：用户与OS交互，trap</li>
                  </ul>
                </li>
                <li>中断管理：ISR->中断服务程序</li>
                <li>中断发生时机
                  <ul>
                    <li>I/O中断：随时发生，延迟处理</li>
                    <li>异常：随时发生，随时处理</li>
                    <li>陷阱：专用指令，特殊处理</li>
                  </ul>
                </li>
                <li>引起中断的因素
                  <ul>
                    <li>人为因素：例如转管指令、trap等</li>
                    <li>程序异常：溢出、非法指令</li>
                    <li>硬件故障</li>
                    <li>I/O设备发起的中断请求</li>
                    <li>外部事件，例如用键盘中断现行程序</li>
                  </ul>
                </li>
              </ul>
              </div>
            </li>
            <li><a href="#" id="link5_2">中断要解决的7个问题</a>
              <div id="thediv5_2" style="display:none">
                <ul>
                  <li>各中断源如何向CPU提出请求：中断请求标记触发器INTR
                    <br>通过对INTR置位向CPU提出中断请求
                    <br>分布位置
                    <ul>
                      <li>分布在各中断源接口电路</li>
                      <li>集中在CPU中断机构内，即由CPU连接到各外设</li>
                    </ul>
                  </li>
                  <li>各中断源同时提出请求怎么响应，即中断判优逻辑
                    <ul>
                      <li>硬件排队：原理为高优先级请求封锁低优先级请求
                        <ul>
                          <li>分散在各中断源接口电路链式排队器</li>
                          <img src="./链式排队1.png">
                          <li>集中在CPU内链式排队器</li>
                          <img src="./链式排队2.png">
                        </ul>
                      </li>
                      <li>软件实现(程序查询)</li>
                      <br>例如可以先查优先级较高的是否掉电
                      <img src="./优先级降序查询.png">
                    </ul>
                  </li>
                  <li>CPU什么条件、时间、方式响应中断
                    <ul>
                      <li>响应条件：
                        <ul>
                          <li>CPU允许中断：EINT，允许中断触发器</li>
                          <li>中断请求：INTR=1</li>
                          <li>其他：主要是以上两项，其他例如I/O设备是否准备好(D)、中断是否被屏蔽MASK等</li>
                        </ul>
                      </li>
                      <li>响应时间：指令执行周期结束，CPU发出查询信号</li>
                      <img src="中断查询.png">
                      <li>响应方式：<strong><attr title="CPU中断周期内由硬件自动完成的指令，不在指令系统内"></attr>中断隐指令</strong>在中断周期完成操作，包括：
                        <ul>
                          <li>保存断点：主要是将PC和PSW入栈或存入特殊位置</li>
                          <li>寻找ISR入口
                            <ul>硬件向量法：向量地址->PC</ul>
                            <li>软件查询法：中断识别程序地址入口 -> PC</li>
                          </li>
                          <li>硬件关中断：S-R触发器自动EINT=0,INTR=1 -> 为了防止保护现场被打断，与是否允许多重中断无关
                            <img src="./硬件关中断.png">
                          </li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li>如何保护现场，如何恢复现场，如何返回
                    <ul>
                      <ul>
                        <li>保护现场：在ISR开头各寄存器内容入栈(断点、PSW由隐指令完成)</li>
                        <li>恢复现场：在ISR结尾各寄存器内容出栈</li>
                        <li>返回：在ISR最后，用一条中断返回指令返回</li>
                      </ul>
                    </ul>
                  </li>
                  <li>如何寻找入口地址
                    <ul>
                      <li>硬件向量法：
                        <ul>
                          <li>step1.向量地址产生
                            <ul>
                              <li>设备编码器：分布在各设备接口</li>
                              <li>集中在CPU的向量地址形成部件
                                <img src="向量地址形成.png">
                              </li>
                            </ul>
                          </li>
                          <li>step2.转向ISR
                            <ul>
                              <li>无条件跳转：向量地址->PC，向量地址存放的是一条无条件跳转指令，直接跳到ISR</li>
                              <li>向量地址表：向量地址存放ISR入口地址而不是指令，处理程序负责用这个地址跳到ISR</li>
                            </ul>
                          </li>
                        </ul>
                      </li>
                      <li>软件查询法
                        <br>由程序员安排跳转指令，并指定跳转地址
                      </li>
                    </ul>
                  </li>
                  <li>处理中断过程中又出现中断怎么办？ -> 多重中断
                    <ul>
                      <li>单重中断：CPU执行ISR时不允许新的中断</li>
                      <li>多重中断/中断嵌套：
                        <ul>
                          <li>概念：CPU执行ISR时允许响应新的中断
                            <br>如下图，每发生一次中断嵌套，断点都会入栈以保证能正常返回被打断的ISR
                          </li>
                          <img src="./多重中断.png">
                          <li>多重中断条件
                            <ul>
                              <li>提前开中断
                                <br>中断隐指令通过硬件自动关中断，需要开中断指令将EINT置1
                              </li>
                              <li>优先级
                                <br>优先级高中断源有权中断中断优先级(这里指处理优先级还是响应优先级要看是否使用了屏蔽字的技术，没有的话两者是相同的)低的中断源
                              </li>
                            </ul>
                          </li>
                          注：下图不包含屏蔽字相关设定
                          <img src="中断服务程序流程.png">
                          <li>屏蔽技术
                            <ul>
                              <li>屏蔽触发器和屏蔽字：动态优先级设定
                                <ul>
                                  <li>接口电路内屏蔽字应用
                                    <br>屏蔽字为1即使D为1，INTR只能为0，无法发出中断请求
                                  </li>
                                  <img src="./屏蔽字_INTR.png">
                                  <li>集中在CPU内的链式排队电路
                                    <br>屏蔽字为1导致INTP恒为0，中断请求被屏蔽
                                  </li>
                                  <img src="./屏蔽字.png">
                                </ul>
                              </li>
                              <li>屏蔽字的设定：ISR内设定
                                <br>如下图，与普通的多重中断示意图相比，保护现场后保存当前屏蔽字并设定新屏蔽字，恢复现场现在不允许打断，恢复后恢复屏蔽字再开中断。即修改屏蔽字的时候要避免中断。
                              </li>
                              <img src="./interrupt.png">
                              <li>屏蔽技术改变优先级
                                <ul>
                                  <li>响应优先级：由硬件排队电路固定，无法改变</li>
                                  <li>处理优先级：
                                    <br>可通过设置屏蔽字改变，从而使得某中断虽然先响应，但执行ISR时被其他高处理优先级中断打断，这个时候实质上是因为屏蔽字修改了响应优先级，其他中断可以响应，从而才表现为可以执行ISR
                                    <br>例子
                                </li>
                                <img src="屏蔽字改变优先级.png">
                                </ul>
                              </li>
                              <li>屏蔽技术用途：人为屏蔽某个中断源，便于程序控制</li>
                            </ul>
                          </li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                </ul>
                
              </div>
            </li>
            <li><a href="#" id="link5_3">中断在多周期和流水线中的实现</a>
              <div id="thediv5_3" style="display:none">
              <ul>
                <li>异常处理工作
                  <ul>
                    <li>将断点保存在EPC(PC-4)</li>
                    <li>根据Cause状态寄存器内异常原因处理异常</li>
                    <li>跳转到异常处理程序(PC)</li>
                  </ul>
                </li>
                <li>多周期
                  <ul>
                    <li>中断和异常操作特点(非流水线)
                      <ul>
                        <li>顺序语义：之前的指令全部执行完，之后的指令还没有执行</li>
                        <li>断点精确：指令异常同步响应，外部中断异步响应(在下一条指令fetch前)</li>
                        <li>现场简明：EPC和Cause</li>
                      </ul>
                    </li>
                    <li>多周期异常处理状态机
                      <br>注意：下图以溢出、非法指令为例，其中溢出可以提前到前一个阶段后执行；其他的中断、异常可以用类似的方法<strong>加入状态</strong>，例如对于I/O中断可以放在下一条指令fetch前检查
                    </li>
                    <img src="./多周期异常状态图.png">
                    <li>多周期异常处理RTL
                      <br>以算数溢出为例，溢出可以在修改算数指令MEM段，改为给PC、EPC、Cause分别赋值处理程序地址、断点地址PC-4(利用ALU算出)、对应的Cause编码；当然也可以修改WB段，错误值写回也无所谓
                      <br>其他的中断、溢出以此类推，和状态机对应即可
                    </li>
                    <li>多周期异常处理数据通路</li>
                    <img src="MIPS_中断.png">
                  </ul>
                </li>
                <li>流水线
                  <ul>
                    <li>非精确处理
                      <br>判断异常，保存现场，清空指令，跳转执行(在同一个posedge clk完成)
                      <ul>
                        <li>方案一
                          <ul>
                            <li>实现：无论哪一段发生异常，不允许后续指令进入流水线，允许已进入流水线指令执行完</li>
                            <li>特点
                              <ul>
                                <li>非精确：断点可能不是异常指令，而是最后进入流水线那条指令</li>
                                <li>可变：不同段发生异常，得到的EPC相对异常指令增量不同</li>
                              </ul>
                            </li>
                          </ul>
                        </li>
                        <li>方案二
                          <ul>
                            <li>实现：将异常指令后续指令排空，异常指令之前的指令正常执行 -> 是一种控制相关
                              <ul>
                                <li>清除异常指令后的全部指令(flush)</li>
                                <li>记录异常原因(Cause)</li>
                                <li>保存异常指令断点(EPC)</li>
                                <li>转到异常服务程序运行(由异常原因决定，例如RISC-V中使用向量表基址加异常向量地址)</li>
                              </ul>
                            </li>
                            <li>数据通路(RISC-V)
                              <br>说明：add在clock6发生溢出，进入clock7的时候，寄存器清空、EPC写入、cause写入、PC更新为处理程序第一条指令地址；先于add的指令不受影响地执行
                              <br><strong>注意</strong>：图中没有画出MEM/WB段flush信号，此信号用于处理访存错误等发生在MEM段的错误；并且CAUSE和EPC的输入不仅仅来自EX，其他流水段也有输入，因为异常可能发生在任何一个流水段，不要误解图中所示。 
                            </li>
                            <img src="./RISC-V_异常流水线.png">
                          </ul>
                        </li>
                        <li>缺点：
                          <ul>
                            <li>异常响应时间长</li>
                            <li>后续指令如果被允许执行可能又会引发错误</li>
                            <li>程序调试不能按要求停在设置好的断点处</li>
                            <li>多个异常并发难以处理</li>
                          </ul>
                        </li>
                      </ul>
                    </li>
                    <li>精确处理：判断异常，暂存错误，到点提交，保存现场，清空指令，跳转执行
                      <ul>
                        <li>实现：
                          <ul>
                            <li>保持异常标记直到提交点(MEM段)</li>
                            <li>提交点如果有异常，那么更新cause、EPC、PC，并清除所有流水段</li>
                            <li>执行完成ISR，返回断点继续执行</li>
                          </ul>
                        </li>
                        <li>本质：使用后援大量寄存器，<strong>安全(指严格按照指令逻辑先后关系处理异常，并把流水线状态完整保存)</strong>停止流水线，从而可重启</li>
                        <li>特点
                          <ul>
                            <li>早期流水段异常抑制后来的异常
                              <br>两层含义：
                              <ul>
                                <li>同一指令处理较早的异常：因为后面的异常可能是早期异常造成的</li>
                                <li>不同指令处理深度最深指令异常：下面图中硬件实现避免了后面指令前面流水段在时间上更早发生异常从而导致对其进行异常处理，无视了逻辑上前面指令的异常(尽管发生在靠后流水段)；提交点异常将后续指令全部flush，抑制后续异常</li>
                              </ul>
                            </li>
                            <li>保证前面指令完成：提交点在MEM，这保证前面的指令WB执行完，必然完成，并且后续指令全部被flush</li>
                          </ul>
                        </li>
                        <li>MIPS提交点实现数据通路</li>
                        <img src="./提交点.png">
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
              </div>
            </li>
            </ul>
          </div>
          <a href="#" id="link5_4"></a><div id="thediv5_4" style="display:none"></div><a href="#" id="link5_5"></a><div id="thediv5_5" style="display:none"></div><a href="#" id="link5_6"></a><div id="thediv5_6" style="display:none"></div>
        </li>

        <li><a href="#" id="link1">存储系统</a>
          <div id="thediv1" style="display:none">
          <ul>
            <li><a href="#" id="link1_1">存储器分类</a>
              <div id="thediv1_1" style="display:none">
              <ul>
                <li>按材料分：半导体、磁表面、光盘</li>
                <li>按存取方式：随机存取、只读、串行访问</li>
                <li>按作用：主存、辅存、缓存</li>
              </ul>
              <img src="./storage_device.png">
            </div>
            </li>
          
            <li><a href="#" id="link1_2">存储器层次结构</a>
              <div id="thediv1_2" style="display:none">
            <br>存储空间、运行速度、成本之间的权衡<br>
            <img src="./storage_hierarchy.png">
            <img src="./storage_hierarchy2.png">
          </div>
            </li>
          
          <li><a href="#" id="link1_3">主存储器</a>
            <div id="thediv1_3" style="display:none">
            <ul>
              <li>指标
                <br>存储容量、存储字长、存取时间(访问时间)、存取周期(大于存取时间)、存储器带宽
              </li> 
              <li>半导体存储芯片
                <ul>
                  <li>基本结构
                    <ul>
                      <li>存储矩阵：具有记忆功能</li>
                      <li>译码驱动电路：翻译地址信号为对应单元的选择信号</li>
                      <li>读写电路：读放大电路、写电路</li>
                      <li>相关总线：数据线、地址线、控制线(读写控制线、片选线)</li>
                    </ul>
                  </li>
                  <img src="./半导体芯片结构.png">
                  <li>译码驱动方式
                    <ul>
                      <li>线选法</li>
                      <li>重合法</li>
                      <img src="./重合法线选法.png">
                    </ul>
                  </li>
                </ul>
              </li>
              <li>RAM
                <ul>
                  <li>SRAM：易失性存储，不掉电维持
                    <ul>
                      <li>时序</li>
                      <img src="./SRAM时序.png">
                    </ul>
                  </li>
                  <li>DRAM：电容信息维持1-2ms
                    <ul>
                      <li>时序</li>
                      <img src="./DRAM时序.png">
                      <li>刷新：将原信息读出再按行写入
                        <ul>
                          <li>分散刷新：刷新插入存取周期，存取周期会变长</li>
                          <li>集中刷新：在刷新周期进行刷新，形成死区</li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li>对比</li>
                  <img src="./SRAMDRAM.png">
                </ul>
              </li>
              <li>ROM：一次性编程，可以存放系统代码</li>
              <li><strong>存储器与CPU连接</strong>
                <ul>
                  <li>扩展要求
                    <ul>
                      <li>位扩展：
                        <br>地址线、控制线公用，数据线分开
                      </li>
                      <li>字扩展：
                        <br>地址线、数据线、读写控制线公用，片选线独立来自地址高位(不参与片内寻址)
                      </li>
                    </ul>
                  </li>
                  <li>存储器元件选择：
                    <ul>
                      <li>RAM：用户程序/数据区，系统工作区</li>
                      <li>ROM：系统程序区</li>
                    </ul>
                    <br>另外还要注意数据位宽，是否需要位拓展
                  </li>
                  <li>译码电路和片选信号
                    <ul>
                      <li>74138译码器等译码器
                        <br>使用高位地址位、MREQ访存控制信号或者恒电压信号驱动译码器控制端
                      </li>
                      <li>地址范围要求：开始地址、最低、最高、连续....
                        <br>越界的避免？ -> 片选信号结合地址某高位一起组成片选
                      </li>
                      <li>片选信号：译码器输出以及地址某高位一起组成片选，选择芯片同时对于某些无效的地址段防止越界(ppt例题1)</li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>访存速度提高策略
                <br>由最初的单体单字到...
                <ul>
                  <li>双端口存储器：两套独立端口</li>
                  <li>单体多字：存储字长大于机器字长，每次总线从存储器取得的数据是若干倍的机器字</li>
                  <img src="./单体多字.png">
                  <li>多体并行
                    <ul>
                      <li>高位交叉：地址连续的数据放在同一存储体内
                      <img src="./高位交叉多体.png"> 
                      <br>连续读取n个字时间：nT
                    </li>
                    <li>低位交叉：地址连续的数据依次循环放入不同存储体内
                      <img src="./低位交叉多体.png"> 
                      <br>连续读取n个字时间：T+(n-1)t，t为完美流水工作情况下启动间隔或者也可以说是总线使用时间，非完美流水(T>nt)要另外考虑
                      <img src= "./完美流水多体并行.png">
                    </li>
                    <br>两者并行访问模式的区别：前者多任务、多处理器访问不同存储体，例如两个存储题一个运行、一个IO；后者并行访问多个字，提高带宽
                    </ul>
                  </li>
                </ul>
              </li>
              <li>容错和校验
                <ul>
                  <li>码距L、检测D位错、纠正C位错
                    <ul>
                      <li>只检错：L >= D+1</li>
                      <li>只纠错：L >= 2C+1</li>
                      <li>检错和纠错：L >= D+C+1</li>
                    </ul>
                  </li>
                  <li>奇偶校验</li>
                  <li>CRC循环冗余校验：(n+k,n)码
                    <br>k >= D+C+1
                  </li>
                  <li>海明码</li>
                </ul>
              </li>
            </ul>
          </div>
          </li>
          <li><a href="#" id="link1_4">☆高速缓冲存储器Cache</a>
            <div id="thediv1_4" style="display:none">
            <ul>
              <li>为什么需要Cache
                <ul>
                  <li>解决CPU运算速度和访存速度不匹配的局面</li>
                  <li>解决CPU和IO访存冲突，让CPU在冲突时访问Cache</li>
                </ul>
              </li>
              <li>原理：程序的局部性</li>
              <li>组成：SRAM，片上的纯硬件实现，对用户透明</li>
              <li>体系分类
                <ul>
                  <li><abbr title="只有一个片上Cache">单一Cache</abbr>和<abbr title="一个片上Cache加一个或多个片外Cache">多级Cache</abbr></li>
                  <li><abbr title="指令和数据共用一个Cache">统一Cache</abbr>和<abbr title="指令和数据Cache分开">分离Cache</abbr></li>
                </ul>
              </li>
              <li>指标
                <br>块长、总容量、命中率、平均访问时间、访问效率<abbr title="Cache单次访问时间/平均访问时间"></abbr>
              </li>
              <li>工作流程
                <br>地址映射、Cache命中、Cache替换
                <img src="./cache_work_flow.png">
              </li>
              <li>Cache映射策略
                <ul>
                  <li>全相联映射
                    <br>映射到任意块，将标记(地址块号)和内容一起写入，查找时利用比较器同时比较全部标记<br>
                    Address = Tag + offset<br>
                    Cache单元：valid + Tag + data<br>
                    <img src="./全相联cache.png">
                  </li>
                  <li>直接映射
                    <br>属于一个同余类的主存块映射到同一Cache块，将标记(地址块号)和内容一起写入，利用主存块号计算Cache块，将标记进行一次比较<br>
                    Address = Tag + index + offset，行号=index mod 行数<br>
                    Cache单元：valid + Tag + data （此时各行隐含index）<br>
                    <img src="./直接映射cache.png">
                  </li>
                  <li>组相联映射
                    <br>组间直接映射，组内全相联映射，组内有v块称为v路组相联<br>
                    Address = Tag + index + offset，组号=index mod 组数<br>
                    Cache单元：valid + 组号 + Tag + data<br>
                    <img src="./组相联Cache.png">
                  </li>
                </ul>
              </li>
              <li>Cache替换策略
                <ul>
                  <li>FIFO</li>
                  <li>随机</li>
                  <li>LFU/least-frequently used</li>
                  <li>LRU/least-recently used</li>
                </ul>
              </li>
              <li>Cache读写策略
                <ul>
                  <li>读Cache流程(即Cache工作流程)
                    <img src="./cache_read.png">
                  </li>
                  <li>写命中时写策略
                    <ul>
                      <li>写直达法：写入Cache和主存</li>
                      <li>写回法：只写入Cache，块被调换时写入主存</li>
                    </ul>
                  </li>
                  <li>写失效时写策略
                    <ul>
                      <li>按写分配(写时取)：先把块调入Cache，再执行写命中写Cache</li>
                      <li>不按写分配(绕写法)：不把块调入Cache，直接写入下一级存储器</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </div>
          </li>
          <li><a href="#" id="link1_5">☆虚拟存储器</a>
            <div id="thediv1_5" style="display:none">
            <ul>
            <li><abbr title="用户编程的空间，逻辑地址空间">虚地址</abbr>到<abbr title="实际的物理存储空间">实地址</abbr>：程序重定向
            <br>逻辑地址空间可以远大于实地址空间 -> 用户编程时可以认为自己的程序运行的进程拥有很大的内存
            <br>逻辑地址空间可以远大于实地址空间 -> 多个用户，限制单个任务的地址空间，并且逻辑地址位数小让页表/段表更小
            </li>
            <li>虚存与Cache
              <br>内存 = 主存 + Cache ， 虚存 = 主存 + 辅存
              <ul>
                <li>不同：侧重点、与CPU数据通路、透明性、未命中代价</li>
                <li>相同点：<strong>利用程序局部性，同时拥有近似高速存储器的速度和低速存储器的容量（如果命中率高）</strong></li>
              </ul>
            </li>
            <li>虚存实现
              <ul>
                <li>页式虚存
                  <li>页表：进程特定
                    <br>逻辑地址 = 逻辑页面号 + 页内偏移
                    <br>页表entry = valid + 虚拟页号 + 权限 + 物理页号
                    <br>地址映射：(页表基址+逻辑页面号->物理页面号->物理页面起始地址) + 页内偏移->物理地址 ， 最多两次访存
                  </li>
                  <li>多级页表</li>
                  <li>反向页表：用于物理页少于逻辑页的情况（一般情况各进程逻辑页小于总物理页数量）</li>
                  <li>TLB/Translation Look-aside Buffer</li>
                  <img src="./complete_memory_access.png">
                </li>
                <li>段式虚存
                  <li>段表：程序特定
                    <br>逻辑地址 = 逻辑段号 + 段内偏移
                    <br>段表entry = valid + 段物理起始地址 + 段长
                    <br>地址映射：(段表基址+逻辑段号->物理段起始地址) + 段内偏移->物理地址 ， 最多两次访存
                  </li>
                </li>
                <li>段页式虚存
                  <li>段表+页表：可重入段是程序特定的，局部变量等在执行时copy到各进程的局部数据段
                    <br>逻辑地址 = 逻辑段号 + 逻辑页号 + 页内偏移
                    <br>段表entry = valid + 页表起始地址 + 段长，页表entry = valid + 虚拟页号 + 权限 + 物理页号
                    <br>地址映射：((段表基址+逻辑段号->页表起始地址) + 逻辑页号) + 页内偏移->物理地址 ， 最多三次访存
                  </li>
                </li>
                <a href="https://blog.csdn.net/low5252/article/details/106075945">段页式存储参考</a>
              </ul>
              <p>三种虚存示意图实现对比
                <br>页表<br>
                <img src="./page_table.png">
                <br>段表<br>
                <img src="./segment_table.png">
                <br>段页式<br>注：如果只有一个段表基址寄存器，且在切换程序时更新，那么基号可以省略
                <br><img src="./seg_page.png">
              </p>
              
            </li>
            <li>虚存替换
              <br>虚存未命中开销远大于Cache未命中
              <ul>
                <li>FIFO</li>
                <li>LRU</li>
                <li>LFU</li>
              </ul>
            </li>
          </ul>
        </div>
          </li>
          <li>辅助存储器</li>
          </ul>
        </div>
        </li>

        <li><a href="#" id="link6">总线</a>
            <div id="thediv6" style="display:none">
            <ul>
              <li><a href="#" id="link6_1">总线概述</a>
                <div id="thediv6_1" style="display:none">
                <ul>
                  <li>总线概念
                    <ul>
                      <li>计算机系统的互连结构，在资源争用的基础上实现计算机各部件<strong>地址、数据、控制信息</strong>的交换。一般而言，总线由多条传输线和数据通路组成，每条线可以传输一位二进制代码。</li>
                      <li>注意：争用意味着每一时刻只能有一个部件向总线发送信息，但是可以有多个部件从总线接收信息</li>
                    </ul>
                  </li>
                  <li>总线分类
                    <ul>
                      <li>数据传送方式：并行/串行总线</li>
                      <li>数据与时钟同步/异步工作：同步/异步总线</li>
                      <li>连接部件：<attr title="连接CPU内运算部件和寄存器">内部</attr>/系统总线
                        <br>系统总线分类
                      <ul>
                        <li>数据总线：双向</li>
                        <li>地址总线：单向</li>
                        <li>控制总线：单向</li>
                      </ul>
                      </li>
                    </ul>
                  </li>
                  <li>总线特性：物理/电气/功能/时间(时序)特性</li>
                  <li><strong>总线性能指标</strong>
                  <ul>
                    <li>总线宽度</li>
                    <li>总线频率：1/传输一次数据时间(总线周期)</li>
                    <li>总线周期/总线时钟周期</li>
                    <li>总线带宽：通常用每秒字节数衡量</li>
                    <li>其他：总线复用、负载能力...</li>
                  </ul>
                  </li>
                  <li>总线标准
                    <ul>
                      <li>总线标准：系统、模块之间互连的标准规范(协议)，模块可以不知对方连接要求，只考虑自身的接口功能要求</li>
                      <li>一些总线标准：ISA,EISA,PCI,USB,AGP...</li>
                      <li>PCI
                        <ul>
                          <li>时钟：独立于CPU时钟</li>
                          <li><strong>突发工作模式/burst mode</strong>：连续传输数据只需给出首地址和burst时间，不用得到一个地址再传一个数据</li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                </ul>
                </div>
              </li>

              <li><a href="#" id="link6_2">总线结构</a>
                <div id="thediv6_2" style="display:none">
                <ul>
                  <li>外部结构
                    <ul>
                      <li>单总线结构
                        <ul>
                          <li>连接在总线上部件要高速完成操作，迅速放弃总线控制权</li>
                          <li>发送到主存地址也发送到其他I/O设备，对I/O设备操作与主存相同，可以指定地址</li>
                          <li></li>
                        </ul>
                      </li>
                      <li>多总线结构：按速率不同分类</li>
                    </ul>
                  </li>
                  <li>内部结构
                    <ul>
                      <li>早期总线内部结构：处理器芯片的引脚延伸，处理器与I/O适配器的通道，与CPU结构密切相关，通用性差</li>
                      <li>现行总线内部结构：把CPU、存储器等都视为总线的设备，总线是标准的，与CPU等无关
                        <br>注：CPU和Cache作为一个整体和总线相连
                        <ul>
                          <li>数据传输总线：数据、地址、控制</li>
                          <li>仲裁总线：总线请求和总线授权</li>
                          <li>中断和同步总线：中断请求和中断响应</li>
                          <li>公用线：时钟、电源...</li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                </ul>
                </div>
              </li>

              <li><a href="#" id="link6_3"><strong>总线仲裁</strong></a>
                <div id="thediv6_3" style="display:none">
                <ul>
                  <li>基本概念
                    <ul>
                      <li>设备主从关系
                        <br><strong>一个主动方</strong>占用总线(总线占用期)，<strong>一个或多个被动方</strong>响应主动方，此时总线忙
                      </li>
                      <li>总线仲裁：对多个设备提出的总线占用请求判优。可根据仲裁电路位置来分类</li>
                    </ul>
                  </li>
                  <li>集中式仲裁：现代总线的一般做法
                    <ul>
                    <li>基本方式：CPU中总线仲裁器负责仲裁,每个设备模块的BR(请求)和BG(授权)连接到仲裁器</li>
                    <li>三种仲裁方式
                      <br>此处参考图也可见ppt参考图，更详细
                    </li>
                    </ul>
                  </li>
                  <table>
                    <thead>
                      <tr>
                        <th style="text-align: left">对比项</th>
                        <th style="text-align: left">链式查询</th>
                        <th style="text-align: left">计数定时</th>
                        <th style="text-align: left">独立请求</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td style="text-align: left">实现方式</td>
                        <td style="text-align: left">类似于排队电路，按连接顺序查询，一旦查询到BR有请求，则不继续往下查询，建立总线忙BS信号</td>
                        <td style="text-align: left">设备通过BR发出请求，仲裁器计数并将计数值通过设备地址线发给各设备，设备地址和计数值相同的设备置总线忙信号BS</td>
                        <td style="text-align: left">每个设备都有自己的BR和BG，仲裁器内部的排队电路根据一定优先次序决定先响应哪个请求</td>
                      </tr>
                      <tr>
                        <td style="text-align: left">优先级</td>
                        <td style="text-align: left">离仲裁器最近的设备优先级最高</td>
                        <td style="text-align: left">计数从0开始：优先级固定<br>计数从中止值开始：优先级相等</td>
                        <td style="text-align: left">nice</td>
                      </tr>
                      <tr>
                        <td style="text-align: left">优点</td>
                        <td style="text-align: left">硬件连线简单且容易扩充</td>
                        <td style="text-align: left">优先级可变<br>对电路故障不敏感</td>
                        <td style="text-align: left">优先级灵活，响应时间快</td>
                      </tr>
                      <tr>
                        <td style="text-align: left">缺点</td>
                        <td style="text-align: left">对电路故障敏感<br>优先级是固定的；优先级低设备很难获得的请求</td>
                        <td style="text-align: left">控制线增加，控制复杂</td>
                        <td style="text-align: left">控制线更多，控制更复杂</td>
                      </tr>
                    </tbody>
                  </table>
                  <img src="./集中式仲裁.png">

                  <li>分布式仲裁：无中央仲裁器
                    <ul>
                      <li>自举分布式仲裁：仲裁期间取回请求线上信号，各自独立的决定自己是否是优先级最高的（优先级固定）</li>
                      <li>冲突检测分布式仲裁：监听总线，发生冲突则用某种方式选择一个使用者(CSMA/CD)</li>
                      <li><strong>并行竞争分布式仲裁</strong>：各设备有自己专属的仲裁号和仲裁器（优先级固定）
                        <ul>
                          <li>具体原理：
                            <ul>
                              <li>各设备若请求总线则将自己的仲裁号发到仲裁总线上，总线的每一根对应一位，只要有设备发送了仲裁号并且仲裁号此位是1，那么该线上为<strong>低</strong>电平(表示这一位有1)</li>
                              <li>若仲裁总线为1(低电平)而仲裁号为0，那么低于该位的所有位仲裁号变为0，高电平被写入总线，表示该仲裁号更小，其不影响更大仲裁号修改仲裁总线<br>若仲裁总线为1(低电平)而仲裁号为1，不影响低位<br>若仲裁总线为0(高电平)，不管仲裁号为多少，不影响低位
                              <br>即最终结果只有当仲裁总线表示的值大于仲裁号该位时，其低位相当于被置0，从而不影响更大仲裁号修改总线
                              </li>
                              <li>最终仲裁线上仲裁号与具有最大仲裁号的设备仲裁号<strong>匹配</strong>，获得总线控制权</li>
                            </ul>
                          </li>
                          <li>帮助理解的例子</li>
                          <img src="./并行竞争例子.png">
                          <img src="./并行竞争分布式仲裁.png">
                        </ul>
                      </li>
                    </ul>
                  </li>
                </ul>
              </div>
              </li>

              <li><a href="#" id="link6_4"><strong>总线通信</strong></a>
                <div id="thediv6_4" style="display:none">
                <ul>
                  <li>总线操作
                    <ul>
                      <li>读操作：地址 -> 命令 -> 数据</li>
                      <li>写操作：地址 -> 数据 -> 命令</li>
                      <li>块传送/猝发式操作(burst)：给出起始地址和burst时间，然后连续写入/读出，不需要重复传地址</li>
                      <li>先读后写/先写后读：只给出一次地址
                        <br>注：先读后写用于共享资源保护，先写后读用于校验
                      </li>
                      <li>广播/广集：一主对多从的写和读
                        <br>广集需要指定数据在总线上进行与或操作，可用于多个中断源检测
                      </li>
                    </ul>
                  </li>
                  <li>总线周期：完成一次总线操作的时间
                    <ul>
                      <li>申请分配：主设备提出申请，仲裁决定下一周期总线归属权</li>
                      <li>寻址阶段：主设备发送设备地址、命令等，启动从设备</li>
                      <li>传送阶段：主、从设备数据交换</li>
                      <li>结束阶段：主设备相关信息从总线上撤出，让出使用权</li>
                    </ul>
                  </li>
                  <li>串行/并行传送、复用
                    <ul>
                      <li>串行传送：单线脉冲传送，每一位平均用的时间 -> 位时间</li>
                      <li>并行传送：多线电位传送</li>
                      <li>复用：分时复用总线，既传地址又传数据</li>
                    </ul>
                  </li>
                  <img src="./串行总线并行总线.png">
                  <li>总线通信方式</li>
                </ul>
                <table>
                  <thead>
                    <tr>
                      <th style="text-align: left">对比项</th>
                      <th style="text-align: left">同步</th>
                      <th style="text-align: left">异步</th>
                      <th style="text-align: left">半同步</th>
                      <th style="text-align: left">分离式</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td style="text-align: left">实现方式</td>
                      <td style="text-align: left">通信双方用统一时钟控制</td>
                      <td style="text-align: left">通信双方一次、两次、三次握手(不互锁、半互锁、全互锁)，需加入两条应答线</td>
                      <td style="text-align: left">同步结合异步，统一时钟控制，从模块利用等待线通知住模块自己没有准备好，主模块插入等待周期以平衡速度</td>
                      <td style="text-align: left">总线周期分为两个子周期，子周期内单向同步通信，例如第一个子周期发送地址、命令、主模块编号，第二个子周期反向发送数据和模块编号<br>两个子周期开始时申请总线控制权，两个子周期之间总线归还控制权</td>
                    </tr>
                    <tr>
                      <td style="text-align: left">总线周期</td>
                      <td style="text-align: left">主设备发出地址和读写命令开始，直到数据传输完成，归还总线</td>
                      <td style="text-align: left">同上</td>
                      <td style="text-align: left">同上</td>
                      <td style="text-align: left">分为两个子周期</td>
                    </tr>
                    <tr>
                      <td style="text-align: left">优点</td>
                      <td style="text-align: left">模块配合简单</td>
                      <td style="text-align: left">允许各部件速度不同</td>
                      <td style="text-align: left">控制方式比异步简单，统一时钟更可靠</td>
                      <td style="text-align: left">准备数据时不占用总线，因此占用期间都在进行有效工作而不等待浪费</td>
                    </tr>
                    <tr>
                      <td style="text-align: left">缺点</td>
                      <td style="text-align: left">强制同步，必须在限定时间内完成操作<br>需按最慢的部件设计公共时钟</td>
                      <td style="text-align: left">有附加位存在，比特率小于同步</td>
                      <td style="text-align: left">等待周期数量不确定</td>
                      <td style="text-align: left">控制复杂</td>
                    </tr>
                    <tr>
                      <td style="text-align: left">使用体系</td>
                      <td style="text-align: left">总线短，各部件存取时间近似</td>
                      <td style="text-align: left">各种体系</td>
                      <td style="text-align: left">各部件速度差异大的简单系统</td>
                      <td style="text-align: left">大型计算机</td>
                    </tr>
                    <tr>
                      <td style="text-align: left">常见相关问题</td>
                      <td style="text-align: left">同步读、写的控制、数据、地址信号</td>
                      <td style="text-align: left"><attr title="只包含数据位">比特率</attr>与<attr title="包含附加位和数据位">波特率</attr>计算</td>
                      <td style="text-align: left">半同步读、写的控制、数据、地址、等待信号</td>
                      <td style="text-align: left">子周期主从关系(都是主设备，当然也都是从设备，都能申请总线控制权)、数据流方向</td>
                    </tr>
                  </tbody>
                </table>
                
                <ul>
                  <li>附：常见问题示意图
                    <br>同步总线读写<br>
                    <img src="同步总线读.png"><img src="同步总线写.png">
                    <br>半同步总线读
                    <br>
                    <img src="半同步总线读.png">
                  </li>
                </ul>
              </div>
              </li>
            </ul>
            </div>
            <a href="#" id="link6_5"></a><div id="thediv6_5" style="display:none"></div>
        </li>
        <li><a href="#" id="link7">I/O</a>
          <div id="thediv7" style="display:none">
          <ul>
            <li><a href="#" id="link7_1">I/O系统概述</a>
              <div id="thediv7_1" style="display:none">
              <ul>
                <li>I/O系统组成
                  <ul>
                    <li>I/O软件
                      <ul>
                        <li>I/O指令：接口模块方式常用，是指令集中的指令，操作码(区分与其他机器指令)+命令码(体现具体操作)+设备码(指明设备)</li>
                        <li>通道指令：具有通道系统的I/O系统常用，不是指令集中的指令，由通道执行。
                          <br>注：CPU执行I/O指令启动设备、查询通道情况后，由通道指令接管I/O设备
                        </li>
                      </ul>
                    </li>
                    <li>I/O硬件
                      <ul>
                        <li>带接口I/O系统：I/O设备，接口模块电路</li>
                        <li>带有通道系统的I/O系统：通道连接一到多个设备控制器，设备控制器连接一到多个同类型设备</li>
                      </ul>
                      <img src="通道系统IO系统.png">
                    </li>
                  </ul>
                </li>
                <li>I/O系统发展阶段
                  <ul>
                    <li>早期阶段</li>
                    <li>接口模块</li>
                    <li>DMA</li>
                    <li>通道结构</li>
                    <li>I/O处理机(外围处理机)</li>
                  </ul>
                </li>
                <table>
                  <thead>
                    <tr>
                      <th style="text-align: left">对比项</th>
                      <th style="text-align: left">早期阶段</th>
                      <th style="text-align: left">接口模块</th>
                      <th style="text-align: left">DMA</th>
                      <th style="text-align: left">通道结构</th>
                      <th style="text-align: left">I/O处理机</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td style="text-align: left">实现方式</td>
                      <td style="text-align: left">每个I/O设备以一套独立逻辑电路和CPU相连</td>
                      <td style="text-align: left">I/O设备通过接口模块以及总线和主机相连，接口中设有数据通路和控制通路</td>
                      <td style="text-align: left">I/O设备通过DMA与主存直接相连</td>
                      <td style="text-align: left">通道作为CPU的从处理器，依据CPU指令进行启动、停止、改变工作状态，通过通道指令独立进行I/O和主存之间信息交换</td>
                      <td style="text-align: left">外围处理机</td>
                    </tr>
                    <tr>
                      <td style="text-align: left">工作特点</td>
                      <td style="text-align: left">CPU和I/O设备串行工作</td>
                      <td style="text-align: left">可用中断方式工作</td>
                      <td style="text-align: left">DMA代替CPU管理I/O，但需要窃取周期占用总线</td>
                      <td style="text-align: left">通道可以独立执行通道指令编写的输入输出程序，但也不是完全独立于CPU的</td>
                      <td style="text-align: left">基本独立于CPU，完成通道完成的I/O控制，还要完成码制变换、纠错等</td>
                    </tr>
                    <tr>
                      <td style="text-align: left">缺点</td>
                      <td style="text-align: left">复杂，浪费CPU资源，难以扩展</td>
                      <td style="text-align: left">交换信息时仍然要占用CPU资源，并非绝对并行</td>
                      <td style="text-align: left">DMA接口多则控制困难，成本高，并且会频繁窃取CPU周期</td>
                      <td style="text-align: left">略</td>
                      <td style="text-align: left">略</td>
                    </tr>
                  </tbody>
                </table>
                <li>I/O系统与主机联系
                  <ul>
                    <li>编址方式
                      <ul>
                        <li>统一编址：I/O指令和访存指令类似，占用主存空间</li>
                        <li>独立编址：I/O指令专门设置，不占用主存空间</li>
                      </ul>
                    </li>
                    <li>传送方式：并行/串行</li>
                    <li>联络方式
                      <ul>
                        <li>立即响应：缓慢I/O设备已经在等待CPU</li>
                        <li>同步</li>
                        <li>异步应答:握手</li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
              </div>
            </li>

            <li><a href="#" id="link7_2">I/O接口</a>
              <div id="thediv7_2" style="display:none">
              <ul>
                <li>基本概念：I/O接口也叫适配器，是主机与I/O设备之间的硬件电路和软件控制
                  <br>注意：端口指接口电路中的寄存器，CPU对I/O设备的操作实际上是对端口的操作
                </li>
                <li>I/O接口功能和组成
                  <ul>
                    <li>选址</li>
                    <li>数据缓冲，数据串并转换</li>
                    <li>传送控制命令</li>
                    <li>反映I/O设备状态：中断请求触发器INTR、中断屏蔽触发器MASK(如果INTR和MASK是分布在接口内的，并且采用程序中断的I/O方式)、完成触发器D、工作触发器B</li>
                  </ul>
                </li>
                <img src="./IO接口.png">
                <li>I/O接口分类</li>
              </ul>
              </div>
            </li>

            <li><a href="#" id="link7_3"><strong>I/O信息交换方式</strong></a>
              <div id="thediv7_3" style="display:none">
              <ul>
                <img src="./IO方式.png">
                <ul>
                  <li>程序查询方式
                    <ul>
                      <li>基本实现：数据在CPU和外围设备之间的传送完全靠计算机程序控制，CPU暂停主程序，主动通过I/O指令查询并转去执行I/O服务程序</li>
                      <li>示意图：多个I/O设备程序查询以及单个I/O设备的服务程序流程
                        <br>注：多个设备按优先级降序循环查询，进入某设备服务例程中仍采取轮询的方式，每个字节都进行相同的忙等操作(CPU控制)，因此会浪费CPU资源
                      </li>
                      <img src="./程序查询方式.png">
                      <li>实例
                        <br>可以结合这里理解总线读操作、写操作的时序，例如为什么读操作给出地址、命令之后，需要等待几个周期才能读取数据，因为这个时候设备正在准备数据（对于同步通信和半同步通信而言，分离式可以认为没有等待）
                      </li>
                      <img src="./程序查询接口.png">
                      <img src="./程序查询实例.png">
                    </ul>
                  </li>
                  <li>程序中断方式
                    <ul>
                      <li>基本实现：CPU给出启动I/O设备命令后，I/O设备与控制器自行准备数据，准备好后以中断的方式提示CPU，此时CPU暂停当前程序转入I/O服务程序</li>
                      <li>示意图：CPU正常执行程序，I/O通过中断占用CPU
                        <br>注：整个过程符合中断那一章描述的过程，包括中断允许、中断请求、中断判优、保护现场、跳转ISR、是否允许多重中断以及屏蔽字的设置
                      </li>
                      <img src="./中断IO方式.png">
                      <li>实例
                        <br>设备在图中1、2、3、4处准备数据，此时CPU并行完成自己的任务，当5处一条指令执行结束，CPU查询到有中断时，转而执行ISR
                      </li>
                      <img src="./中断IO方式接口.png">
                      <img src="./中断IO示例1.png"><img src="./中断IO示例2.png">
                    </ul>
                  </li>
                  <li>DMA方式
                    <ul>
                      <li>基本实现：DMA控制器从CPU获取基本I/O信息(主存位置、计数、命令等)并申请总线控制权后，完全接管总线，直接和主存进行数据交换，不经过CPU</li>
                      <li>三种实现：</li>
                        <table>
                          <thead>
                            <tr>
                              <th style="text-align: left">对比项</th>
                              <th style="text-align: left">停止CPU访问内存</th>
                              <th style="text-align: left">周期窃取/挪用</th>
                              <th style="text-align: left">DMA和CPU交替</th>
                            </tr>
                          </thead>
                          <tbody>
                            <tr>
                              <td style="text-align: left">实现方式</td>
                              <td style="text-align: left">DMA申请到控制权后，占用总线和主存直到完成数据传送</td>
                              <td style="text-align: left">I/O设备发出DMA请求时，I/O设备挪用总线占用权一个或多个主存周期</td>
                              <td style="text-align: left">CPU和DMA交替访问主存</td>
                            </tr>
                            <tr>
                              <td style="text-align: left">工作特点</td>
                              <td style="text-align: left">CPU和I/O设备串行工作</td>
                              <td style="text-align: left">如果CPU正在访存,则访存结束让出总线占用权；若两者同时申请，DMA优先，防止数据丢失</td>
                              <td style="text-align: left">将一个CPU周期分成两份，CPU和DMA轮流访存</td>
                            </tr>
                            <tr>
                              <td style="text-align: left">适合场景</td>
                              <td style="text-align: left">数据传输速率很高的设备</td>
                              <td style="text-align: left">I/O设备读写周期大于主存存取周期，因为DMA接口主存存取存在延迟(2~5倍)</td>
                              <td style="text-align: left">CPU周期长于存取周期的，保证CPU和DMA在C1和C2内完成存取</td>
                            </tr>
                            <tr>
                              <td style="text-align: left">优点</td>
                              <td style="text-align: left">简单</td>
                              <td style="text-align: left">兼顾I/O访问和CPU、主存效率</td>
                              <td style="text-align: left"><strong>不需要</strong>申请、建立、归还总线控制权，总线控制权由C1、C2控制，CPU不暂停也不等待，DMA效率高</td>
                            </tr>
                            <tr>
                              <td style="text-align: left">缺点</td>
                              <td style="text-align: left">CPU基本处于不工作状态<br>一般数据准备时间总是长于主存存取周期，造成浪费</td>
                              <td style="text-align: left">每窃取一次都要申请、建立、归还控制权</td>
                              <td style="text-align: left">硬件逻辑复杂</td>
                            </tr>
                          </tbody>
                        </table>
                      <img src="./三种DMA.png">
                      <li>实例：<strong>DMA接口和DMA过程</strong>
                        <ul>
                          <li>DMA接口以及各寄存器作用：主存地址寄存器AR、字计数寄存器WC、数据缓冲寄存器BR、设备地址寄存器DAR</li>
                          <li>DMA接口模块作用：中断机构、DMA控制逻辑</li>
                          <li>DMA过程：预处理->数据传送->后处理
                            <br>以输出数据为例：
                            <ul>
                              <li>预处理：CPU给DMA预置主存起始地址、传输方向(读主存)、字计数、设备地址并启动设备</li>
                              <li>数据传输
                                <br>当缓冲区空(被I/O设备拿走)时，I/O设备准备好，设备向DMA接口发送请求，DMA接口向CPU申请总线控制权,CPU授权给DMA，DMA将地址送至内存并命令存储器读，DMA通知设备获得DMA周期(DACK响应)并为下一个字交换做准备，主存将
                                读取数据送到缓冲区，设备从缓冲区读取数据，修改主存地址和计数值，若溢出则申请中断，否则继续传送。注意：继续传送指的是等待I/O设备准备好，再进行DMA请求，一般而言I/O设备的准备时间是长于存取周期的，因此对于周期窃取方法，DMA每窃取一个周期进行一个字的存取，I/O设备都要准备一会，这个时候总线、存储器访问权利归还给CPU；即
                                对于周期窃取方式，每传一个字都要重新进行DMA请求，但是对于禁止CPU访问存储器的DMA方式，可以不像上面的流程图那样实现，也可以长时间占用总线，而不用每个字都请求再归还。
                              </li>
                              <li>后处理：CPU跳转到中断服务程序，包括校验内存中结果，若发生错误转错误处理程序，若继续传输则预处理DMA接口，若不需要继续传输则关闭设备</li>
                            </ul>
                          </li>
                        </ul>
                      </li>
                      <img src="./DMA接口.png">
                      <img src="./DMA过程.png">

                      <li>DMA接口与系统连接方式：公共请求和独立请求
                        <img src="./DMA连接.png">
                      </li>
                      <li>DMA接口类型：选择型和多路型
                        <br>区别在于：物理上都与多个设备相连，但逻辑上允许一个/多个设备连接、同时工作
                      </li>
                      <li>DMA与程序中断、程序查询对比</li>
                      <img src="./dma中断对比.png">
                      <img src="三种IO比较.png">
                    </ul>
                  </li>
                  <li>通道方式
                    <ul>
                      <li>具体实现：通道接受CPU的I/O指令，自己从存储器取通道指令，完成和I/O指令指定的外设的数据传输
                      </li>
                      <li>组织方式：主机-通道-设备控制器-设备，主机连接多个通道，通道连接多个设备</li>
                      <li>通道的功能</li>
                      <img src="./通道功能.png">
                    </ul>
                  </li>
                </ul>
                <table>
                  <thead>
                    <tr>
                      <th style="text-align: left">对比项</th>
                      <th style="text-align: left">程序查询</th>
                      <th style="text-align: left">程序中断</th>
                      <th style="text-align: left">DMA</th>
                      <th style="text-align: left">通道</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td style="text-align: left">实现方式</td>
                      <td style="text-align: left">CPU通过I/O指令，循环查询各设备情况，并根据设备状态进行操作</td>
                      <td style="text-align: left">CPU启动设备后执行原程序,I/O设备以中断通知CPU数据准备完成，CPU调用ISR处理</td>
                      <td style="text-align: left">I/O设备通过DMA与主存直接相连，通过DMA接口来与I/O设备、内存交互</td>
                      <td style="text-align: left">通道作为CPU的从处理器，依据CPU指令进行启动、停止、改变工作状态，执行有限通道指令指令集合，独立进行I/O和主存之间信息交换，结束通过中断通知CPU</td>
                    </tr>
                    <tr>
                      <td style="text-align: left">优点</td>
                      <td style="text-align: left">如果I/O设备较快影响不大，简单</td>
                      <td style="text-align: left">可用中断方式工作</td>
                      <td style="text-align: left">DMA代替CPU管理I/O，适合快速传输大量数据</td>
                      <td style="text-align: left">提高并行操作能力</td>
                    </tr>
                    <tr>
                      <td style="text-align: left">缺点</td>
                      <td style="text-align: left">CPU忙等从而浪费资源，数据在CPU和外围设备之间的传送完全靠计算机程序控制</td>
                      <td style="text-align: left">执行ISR时仍然要占用CPU资源，并非绝对并行</td>
                      <td style="text-align: left">DMA接口多则控制困难，成本高，并且会频繁窃取CPU周期<br>DMA不能处理数据传输过程中的错误，需要后处理完成</td>
                      <td style="text-align: left">通道控制比较复杂</td>
                    </tr>
                  </tbody>
                </table>
                
              </ul>
              </div>
            </li>

            <li><a href="#" id="link7_4">I/O设备</a>
              <div id="thediv7_4" style="display:none">
              <ul></ul>
              </div>
            </li>

            <li><a href="#" id="link7_5">辅助存储器</a>
              <div id="thediv7_5" style="display:none">
              <ul>
                <li>磁记录原理：编码方式</li>
                <img src="./磁编码方式.png">
                <li>磁盘
                  <ul>
                    <li>寻址方式：寻道+旋转(等待)</li>
                    <li>指标：<attr title="半径方向轨道密度">道密度</attr>、位密度、容量、<attr title="位密度*运行速度">传输率</attr></li>
                  </ul>
                </li>
              </ul>
              </div>
            </li>
          </ul>
          </div>
        </li>

      </ul>
      <hr>
      <h2 id="cod-summary">Summary</h2>
      <ul>
        <li>计算机的各种性能指标</li>
        <img src="./各类性能指标.png">
      </ul>
      <hr>
      <h2 id="cod-question">Questions</h2>
      <p>This part includes frequently-asked and important questions in COD.</p>
      <ul>
        <h3>第一章、计算机系统概论</h3>
        <li>计算机系统由哪两部分组成？计算机系统的层次结构是什么样的？软件和硬件的逻辑等价性指什么？(☆☆☆)</li>
        <li>计算机的五大组成部分分别是什么？各部分的功能是什么？(☆☆)</li>
        <li>当点击一个可执行文件hello_world的时候，计算机内部完成了什么样的过程来执行这个程序？(☆)</li>
        <li>指令的执行过程是什么样的？</li>
        <li>冯诺依曼结构计算机的特点是什么？哈佛结构呢？(☆☆)</li>
        <li>计算机组成和计算机体系结构之间的关系是什么样的？(☆)</li>
        <li>机器字长、数据字长、存储字长分别指什么？它们之间的关系是什么？按字读取中的字指什么？它与字节什么关系？(☆☆☆)</li>
        <li>计算机存储容量如何计算？(☆☆☆)</li>
        <li>如何评价计算机的运算<abbr title="CPU时间">速度或者说性能</abbr>？能否用MIPS或者MFLOPS来评价性能？f、CPI、IC分别指什么？它们分别反映了计算机哪一方面的性能？如何计算总的CPU时间？测试运算速度的方法有哪些？(☆☆☆)</li>
        <li>计算机发展面临几个“墙”是什么？对于存储墙、I/O墙，有什么样的解决方案？(☆)</li>
        <li>Amdahl定律是什么？如何理解Amdahl定律？  <abbr title="用于预测改进某部分导致的总体加速">答案</abbr>(☆☆)</li>
        <li>集成电路成本（单片成本）如何计算？最终单片芯片的成本如何计算？为什么量产会让芯片成本降低？(☆)</li>
        <br>
        <h3>第二章、指令系统</h3>
        <li>微指令指什么？宏指令指什么？机器指令指什么？(☆)</li>
        <li>完善的指令系统要做到什么样的兼容性？如何实现？(☆☆)</li>
        <li>系列计算机哪两点基本<attr title="基本指令系统、基本体系结构">相同</attr>？(☆☆☆)</li>
        <li>指令系统的四点性能要求<attr title="完备性、有效性、规整性、兼容性">是什么</attr>？</li>
        <li>高级语言是否与指令系统相关联？低级语言呢？不同机器指令系统相同么，或者说指令系统是否会影响机器硬件结构？指令系统会影响机器的哪<attr title="硬件结构、系统软件、机器适用范围">三个方面</attr>？(☆☆)</li>
        <li>指令的一般格式是什么样的？操作码和地址码的作用分别是什么？按照操作码长度是否可变，指令可以分为哪两类？其中变长操作码也叫什么技术？具体是怎么做的？变长操作码在分配操作码时有什么原则？扩展操作码中短操作码数量的增加是否会导致长操作码指令数量减少？为什么？(☆☆☆)</li>
        <li>按照地址码个数，指令可以被分为哪几类？</li>
        <li>按照操作数物理地址位置，指令可以分为哪三类？执行速度最快的是哪一类？访存次数最多的是哪一类？</li>
        <li>指令字长指什么？按照指令字长和机器字长的关系，可以把指令分为哪几种？按照指令字长是否可变，可以把指令分为哪两种？这两种的优缺点分别是什么？(☆☆☆)</li>
        <li>什么是指令助记符？指令助记符出现在什么程序中？指令助记符的作用是？(☆)</li>
        <li>指令操作数的类型有哪些？</li>
        <li>计算机内的数据存放的最小单位一般是什么？访问的单位是什么？为什么要边界对齐？边界对齐具体是怎么做的？字节顺序有哪两种？它们的区别体现在哪里？(☆☆☆)</li>
        <li>指令的寻址方式有哪些？数据的寻址方式有哪些（重点：偏移寻址）？(☆)</li>
        <li>什么是程序的局部性原理？此原理体现在什么类型的寻址方式里？(☆☆☆)</li>
        <li>对于偏移寻址，其中的相对寻址、基址寻址、变址寻址分别指什么？基址寻址、变址寻址有什么区别？它们分别有什么作用？(☆☆)</li>
        <li>CISC和RISC分别指什么？指令数目、指令格式、寻址方式谁更多？其中哪一种指令字长固定？哪一种指令多为单机器周期？两种计算机的指令使用频率分布如何？可访存指令有什么区别？寄存器数目谁更多？它们分别使用了什么样的技术？RISC、CISC的缺点有哪些？为什么会出现从CISC到RISC的转变？(☆☆☆)</li>
        <li><attr title="小端、字节、不要求">RISC-V</attr>采用大端还是小端模式？内存按什么编址？是否要求边界对齐？RISC-V的指令可以分为<attr title="R,I,S,SB,UJ,U"></attr>哪几类？每一类包含完成什么功能的指令？RISC-V如何将一个32位数字加载进入寄存器？RISC-V的寻址方式有<attr title="立即寻址、寄存器寻址、PC相对寻址、(寄存器)基址寻址">哪些</attr>？</li>
        <li><attr title="指令序列，没有嵌入分支和分支目标，编译器可以识别基本块并优化，先进处理器可以并行加速基本块">什么是</attr>基本块？</li>
        <br>
        <h3>第三章、RISC-V处理器设计</h3>
        <li>对着数据通路图，熟悉各指令单周期、多周期、流水线的路径，熟悉多周期的有限状态机，向数据通路中添加新的指令(jal等)。(☆☆☆)</li>
        <li>如何确定单周期的指令周期(机器周期)？(☆☆☆)</li>
        <li>多周期和单周期实现的区别在哪里？多周期为什么可以合并指令存储器和数据存储器？多周期为什么理论上要比单周期快？实际的实现中多周期<attr title="不一定，因为多周期添加了部件，可能会导致机器周期变长，并且具体运行时间还要看具体程序">一定比单周期快么</attr>？如果按五段划分，多周期每条指令在这五个周期内执行什么任务？</li>
        <li>理想流水线的加速比为多少？IPC=CPI=？实际的流水线CPI应为多少？(☆☆)</li>
        <li>结构相关指什么？有什么解决方法？(☆☆☆)</li>
        <li>结构相关指什么？数据前递指什么？能否用数据前递解决所有的数据相关？load-use数据相关需要如何解决？向某寄存器加载数据然后将该寄存器内数据存入内存是否是load-use相关？如果认为是怎么解决？如果认为不是怎么解决？(☆☆☆)</li>
        <li>控制相关指什么？如何解决控制相关？(☆☆☆)</li>
        <li>流水线多发技术的目的是什么？超标量技术指？是否需要编译器支持？超标量计算机能不能重新安排指令的顺序？能不能超流水线指？超长指令字指？(☆☆☆)</li>
        <br>
        <h3>第五章、中断与异常</h3>
        <li>中断源如何提出中断请求？CPU对中断的响应优先级和处理优先级有什么区别？如何实现这两个优先级的判断？为什么有时多个中断请求的服务曲线会出现锯齿？(☆☆☆)</li>
        <li>CPU什么条件下才会对中断请求进行响应？响应中断(即CPU发出查询信号)的时间一般是什么时候？(☆☆☆)</li>
        <li>什么是中断隐指令？中断隐指令在中断周期完成了哪些操作？其中关中断为什么说是硬件自动的？寻找ISR的入口有哪两种方法？其中硬件向量法有哪两种不同的实现？(☆☆☆)</li>
        <li>保护现场要进行哪些操作？这些操作哪一些是由中断隐指令/ISR完成的？如何恢复现场？如何返回？(☆☆☆)</li>
        <li>单重中断指什么？单重中断的流程是什么样的？多重中断指什么？多重中断的流程是什么样的？进行多重中断的前提是什么？为什么保存现场前要通过中断隐指令关中断？多重中断的流程中为什么开始执行服务程序前又要通过开中断指令打开中断，而单重中断则是在返回前打开？(☆☆☆)</li>
        <li>屏蔽字的作用是什么？屏蔽字在硬件上有哪两种实现？为什么屏蔽字能使得处理优先级和响应优先级不同？屏蔽字的保存、设置、恢复是由谁完成的？如果考虑屏蔽技术，那么多重中断的流程是什么样的？(☆☆☆)</li>
        <li>在多周期实现中，如果想要加入异常处理或者中断功能，需要对状态机和数据通路做什么修改？已经具备中断、异常处理功能的多周期CPU，想要加入新的中断要考虑哪些问题？(☆☆☆)</li>
        <li>流水线非精确异常处理两种方案分别怎么实现？有什么缺点？(☆☆☆)</li>
        <li>为什么流水线精确处理异常方法中，提交点要设置在MEM段？精确处理方案中如果多个异常并发怎么处理？精确方案中会不会出现不同指令异常处理顺序颠倒的情况？EPC和cause应该设置在哪一段？为什么？(☆☆☆)</li>
        <li>某指令写回目标寄存器地址越界属于什么异常？</li>
        <li>对比一下多周期、流水线非精确、流水线精确异常实现的区别？(☆☆☆)</li>
        <br>
        <h3>第六章、存储系统</h3>
        <li>存储器层次结构是什么样的？为什么存在存储器的层次结构？(☆☆☆)</li>
        <li>存储容量、存储字长、存取时间、存取周期、存储器带宽分别指什么？(☆☆☆)</li>
        <li>半导体存储芯片的译码驱动电路有什么作用？读写电路呢？控制信号的片选信号有什么用？(☆)</li>
        <li>DRAM和SRAM有什么区别？为什么DRAM需要刷新？死区指什么？</li>
        <li>CPU和存储器的连接要注意哪些问题？(☆☆☆)</li>
        <li>如何提升存储器带宽(存取周期、字长、存储体)？双端口存储器如何实现？单体多字和多体并行区别在哪里？低位交叉和高位交叉有什么区别？它们的并行访问模式区别在哪里？在这两种实现中读取连续的n个字的时间分别是多少？</li>
        <li>码距、检错位数、纠错位数之间的关系是怎样的？奇偶校验的码距为多少？(n+k,n)码什么意思？CRC循环冗余校验生成多项式和码距什么关系？如何用生成多项式计算校验位？海明码如何计算？如果数据为k位，海明码共r位，那么他们之间满足什么样的关系？为什么？(☆☆☆)</li> 
        <li>(☆)为什么要有Cache？Cache改善性能的原理是什么？为什么我们很少在编程时直接和Cache打交道，即使是在内核态编程也只是涉及到虚拟地址和物理地址？</li>
        <li>(☆)Cache块或者说Cache行指什么？Cache和CPU数据交换的最小单位是？</li>
        <li>(☆☆)Cache命中率怎么计算？是不是Cache容量越大，Cache命中率越高？如果Cache容量有限，Cache行越大，是否Cache命中率越高？</li>
        <li>(☆☆☆)包含Cache的CPU一次完整的访存过程是什么样的？</li>
        <li>(☆☆☆)Cache的映射策略有哪三种？哪种策略的相联度最高(即冲突率最小)？为什么冲突率越小，失效率越小？为什么对于直接相连和组相联策略，要把index放在地址中间几位，tag放在地址高位？（为了让同余类是均匀分布的）</li>
        <li>(☆☆☆)读Cache的流程是什么样的？</li>
        <li>(☆☆☆)写命中时写直达和写回有什么区别？它们花费的时间是多少？写失效时按写分配和绕写法有什么区别？以写直达+按写分配为例，写Cache时的工作流程是什么样的？</li>    
        
        <br>
        <h3>第七章、总线</h3>   
        <li>使用总线的设备的主从关系指什么？(☆)</li>
        <li>总线时钟周期和总线周期有什么区别？</li>
        <li>为什么会出现从单总线到多总线结构的转变？(即多总线结构的意义)总线包括哪几种不同作用的总线？</li>
        <li>系统总线分为哪三种？他们的数据方向是什么样的？(☆☆☆)</li>
        <li>为什么要进行总线仲裁？集中仲裁的方式有哪三种？它们的实现和仲裁优先级是什么样的？分布式仲裁有哪三种？它们的实现和仲裁优先级是什么样的？(☆☆☆)</li>
        <li>总线读、写操作控制、数据、地址信号时序如何？(☆☆☆)</li>
        <li>总线周期一般指什么？总线周期怎么计算？一个总线周期可以分成哪四个阶段？(☆☆☆)</li>
        <li>总线串行传送和并行传送在编码上有什么区别？(☆☆☆)</li>
        <li>总线的四种通信方式是什么？各自的优缺点？同步通信的读写控制、数据、地址信号时序如何？与半同步相比有什么区别？异步通信需要加入新的总线么？比特率和波特率有什么区别？怎么将异步通信改为同步通信？分离通信的两个子周期是否需要分别申请总线使用权？两个子周期的通信是单向还是双向的？以CPU从存储器读取数据为例,两个子周期主从关系如何?(☆☆☆)</li>
        <li>总线控制器本质上是什么？如果CPU想要从存储器读取某地址的数据，整个过程是什么样的(请求、仲裁、控制权、通信方式对应时序、归还控制)？如果是CPU从I/O设备读取值和从存储器读取值为什么对于总线来说没有差异(标准接口，抽象封装分层)？(☆☆☆)</li>
        <br>
        <h3>第八章、IO系统</h3> 
          <li>I/O系统的软件部分中I/O指令和通道指令有什么区别？(☆☆☆)</li>
          <li>I/O系统硬件部分中，采用接口结构的I/O系统一般包括哪两部分？采用通道结构的I/O系统一般是如何连接的？(☆)</li>
          <li>I/O系统的发展可以分为哪几个阶段？描述一下从上一个阶段到下一个阶段的各自原因？</li>
          <li>I/O系统的编址有哪两种方式？数据传送方式呢？(☆)</li>
          <li>I/O接口也叫什么？接口和端口的关系是什么？I/O接口的五个组成部分是什么？分别对应什么功能？(☆☆☆)</li>
          <li>I/O信息交换方式有哪四种？其中主要由程序实现的是？主要由硬件实现的是？(☆☆☆)
            <ul>
              <li>程序查询的方式基本流程是什么样的？如果CPU要执行从外设读的指令，采用程序查询方法的整个过程是什么样的？为什么程序查询方法比较浪费CPU资源？</li>
              <li>程序中断方式进行从外设读数据的操作流程是什么样的？CPU什么时间可以响应来自IO设备的中断？CPU在什么阶段需要暂停主程序执行？如果设备工作过程中出现异常是否能够要求CPU处理？</li>
              <li>DMA本质上是什么？DMA控制器中的主存地址寄存器AR、字计数寄存器WC、数据缓冲寄存器BR、设备地址寄存器DAR分别有什么作用？DMA和CPU访问主存有哪三种不同的方式？详细描述从外设读数据的DMA过程？此过程与向外设写数据有什么不同？DMA过程中外设发生异常是否能够立刻解决？CPU对DMA接口的预处理和后处理做了什么？</li>
              <li>DMA接口和系统的连接方式中公共连接和独立连接有什么区别？DMA接口选择型和多路型有什么区别？(☆)</li>
              <li>通道和CPU是什么关系？通道能执行什么指令？通道需要具备的功能有什么？</li>
            </ul>
          </li>
          <li>磁盘的道密度、位密度、容量、传输率怎么计算？磁盘的寻址方式是什么？(☆☆☆)</li>
          <li>磁存储介质的编码中NRZ、NRZ1、调相PM、调频FM和改进调频MFM分别是怎么做的？(☆☆☆)</li>
        </h3>  
      </ul>
    <br>
    <hr>
    <p><a href="https://shaofengwu123.github.io/">Back</a></p>
    </section>
  </div>

  <footer>
    <p>Project maintained by <a href="https://github.com/ShaofengWu123">ShaofengWu123</a></p>
    <p>© 2021 GitHub, Inc.</p>
  </footer>
</div>


</body>
</html>